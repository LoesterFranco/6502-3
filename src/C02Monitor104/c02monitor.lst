ca65 V2.18 - Git cab4910a
Main file   : c02monitor.s
Current file: c02monitor.s

000000r 1               ;
000000r 1               ;***************************************************
000000r 1               ;*  C02Monitor 1.4 (c)2013-2017 by Kevin E. Maier  *
000000r 1               ;*    Extendable BIOS and Monitor for 65C02 CPU    *
000000r 1               ;*                                                 *
000000r 1               ;* Basic functions include:                        *
000000r 1               ;*  - Byte/Text memory search                      *
000000r 1               ;*  - CPU register display/modify                  *
000000r 1               ;*  - Memory fill, move, compare, examine/edit     *
000000r 1               ;*  - Xmodem/CRC Loader with S-Record support      *
000000r 1               ;*  - Input buffer Macro utility up to 127 bytes   *
000000r 1               ;*  - EEPROM Program utility (Atmel Byte-write)    *
000000r 1               ;*  - RTC via 65C22 showing time since boot        *
000000r 1               ;*  - 1ms timer delay via 65C22                    *
000000r 1               ;*  - Table-driven Disassembler for W65C02S        *
000000r 1               ;*  - Monitor space increased for future expansion *
000000r 1               ;*  - Monitor version change to match BIOS version *
000000r 1               ;*  - Added Loop Counter for Macro operation       *
000000r 1               ;*                                                 *
000000r 1               ;*                  07/11/17 KM                    *
000000r 1               ;*   Uses <6KB EEPROM - JMP table page at $FF00    *
000000r 1               ;*     Uses one page for I/O: default at $FE00     *
000000r 1               ;*         Default assembly start at $E000:        *
000000r 1               ;*                                                 *
000000r 1               ;*  C02BIOS 1.4 (c)2013-2017 by Kevin E. Maier     *
000000r 1               ;*  - BIOS in pages $F8-$FD, $FF                   *
000000r 1               ;*  - Full duplex interrupt-driven/buffered I/O    *
000000r 1               ;*  - extendable BIOS structure with soft vectors  *
000000r 1               ;*  - soft config parameters for all I/O devices   *
000000r 1               ;*  - monitor cold/warm start soft vectored        *
000000r 1               ;*  - fully relocatable code (sans page $FF)       *
000000r 1               ;*  - precision timer services 1ms accuracy        *
000000r 1               ;*  - delays from 1ms to 49.71 days                *
000000r 1               ;*  - basic port services for 6522 VIA             *
000000r 1               ;*  - moved BEEP to main Monitor, CHRIN_NW in BIOS *
000000r 1               ;*  - BIOS space increased for future expansion    *
000000r 1               ;*                                                 *
000000r 1               ;*   Note default HW system memory map as:         *
000000r 1               ;*         RAM - $0000 - $7FFF                     *
000000r 1               ;*         ROM - $8000 - $FDFF                     *
000000r 1               ;*         I/O - $FE00 - $FEFF                     *
000000r 1               ;*         ROM - $FF00 - $FFFF                     *
000000r 1               ;*                                                 *
000000r 1               ;***************************************************
000000r 1               ;
000000r 1               ;	PL	66	;Page Length
000000r 1               ;	PW	132	;Page Width (# of char/line)
000000r 1               ;	CHIP	W65C02S	;Enable WDC 65C02 instructions
000000r 1               ;	PASS1	OFF	;Set ON when used for debug
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               ;*************************
000000r 1               ;* Page Zero definitions *
000000r 1               ;*************************
000000r 1               ;Reserved from $00 to $AF for user routines
000000r 1               ;NOTES:
000000r 1               ;	locations $00 and $01 are used to zero RAM (calls CPU reset)
000000r 1               ;	EEPROM Byte Write routine loaded into Page Zero at $00-$14
000000r 1               ;
000000r 1               PGZERO_ST	=	$B0	;Start of Page Zero usage
000000r 1               ;
000000r 1               ;	Page Zero Buffers used by the default Monitor code
000000r 1               ; - Two buffers are required;
000000r 1               ;	DATABUFF is used by the HEX2ASC routine (6 bytes)
000000r 1               ;	INBUFF is used by RDLINE routine (4 bytes)
000000r 1               BUFF_PG0	=	PGZERO_ST	;Default Page zero location for Monitor buffers
000000r 1               ;
000000r 1               ;INBUFF is used for conversion from 4 HEX characters to a 16-bit address
000000r 1               INBUFF		=	BUFF_PG0	;4 bytes ($B0-$B3)
000000r 1               ;
000000r 1               ;DATABUFF is used for conversion of 16-bit binary to ASCII decimal output
000000r 1               ; note string is terminated by null character
000000r 1               DATABUFF	=	BUFF_PG0+4	;6 bytes ($B4-$B9)
000000r 1               ;
000000r 1               ;16-bit variables:
000000r 1               HEXDATAH	=	PGZERO_ST+10	;Hexadecimal input
000000r 1               HEXDATAL	=	PGZERO_ST+11
000000r 1               BINVALL		=	PGZERO_ST+12	;Binary Value for HEX2ASC
000000r 1               BINVALH		=	PGZERO_ST+13
000000r 1               COMLO			=	PGZERO_ST+14	;User command address
000000r 1               COMHI			=	PGZERO_ST+15
000000r 1               INDEXL		=	PGZERO_ST+16	;Index for address - multiple routines
000000r 1               INDEXH		=	PGZERO_ST+17
000000r 1               TEMP1L		=	PGZERO_ST+18	;Index for word temp value used by Memdump
000000r 1               TEMP1H		=	PGZERO_ST+19
000000r 1               TEMP2L		=	PGZERO_ST+20	;Index for Text entry
000000r 1               TEMP2H		=	PGZERO_ST+21
000000r 1               PROMPTL		=	PGZERO_ST+22	;Prompt string address
000000r 1               PROMPTH		=	PGZERO_ST+23
000000r 1               SRCL			=	PGZERO_ST+24	;Source address for memory operations
000000r 1               SRCH			=	PGZERO_ST+25
000000r 1               TGTL			=	PGZERO_ST+26	;Target address for memory operations
000000r 1               TGTH			=	PGZERO_ST+27
000000r 1               LENL			=	PGZERO_ST+28	;Length address for memory operations
000000r 1               LENH			=	PGZERO_ST+29
000000r 1               ;
000000r 1               ;8-bit variables and constants:
000000r 1               BUFIDX		=	PGZERO_ST+30	;Buffer index
000000r 1               BUFLEN		=	PGZERO_ST+31	;Buffer length
000000r 1               IDX				=	PGZERO_ST+32	;Temp Indexing
000000r 1               IDY				=	PGZERO_ST+33	;Temp Indexing
000000r 1               TEMP1			=	PGZERO_ST+34	;Temp - Code Conversion routines
000000r 1               TEMP2			=	PGZERO_ST+35	;Temp - Memory/EEPROM/SREC routines - Disassembler
000000r 1               TEMP3			=	PGZERO_ST+36	;Temp - EEPROM/SREC routines
000000r 1               CMDFLAG		=	PGZERO_ST+37	;Command Flag - used by RDLINE & others
000000r 1               OPCODE		=	PGZERO_ST+38	;Saved Opcode
000000r 1               ;
000000r 1               ;Xmodem transfer variables
000000r 1               CRCHI			=	PGZERO_ST+39	;CRC hi byte  (two byte variable)
000000r 1               CRCLO			=	PGZERO_ST+40	;CRC lo byte - Operand in Disassembler
000000r 1               CRCCNT		=	PGZERO_ST+41	;CRC retry count - Operand in Disassembler
000000r 1               ;
000000r 1               PTRL			=	PGZERO_ST+42	;Data pointer lo byte - Mnemonic in Disassembler
000000r 1               PTRH			=	PGZERO_ST+43	;Data pointer hi byte - Mnemonic in Disassembler
000000r 1               BLKNO			=	PGZERO_ST+44	;Block number
000000r 1               LPCNTL		=	PGZERO_ST+45	;Loop Count low byte
000000r 1               LPCNTH		=	PGZERO_ST+46	;Loop Count high byte
000000r 1               LPCNTF		=	PGZERO_ST+47	;Loop Count flag byte
000000r 1               ;
000000r 1               ;	BIOS variables, pointers, flags located at top of Page Zero.
000000r 1               BIOS_PG0	=	$E0	;PGZERO_ST+96	;Start of BIOS page zero use ($E0-$FF)
000000r 1               ;	- BRK handler routine
000000r 1               PCL				=	BIOS_PG0+0	;Program Counter Low index
000000r 1               PCH				=	BIOS_PG0+1	;Program Counter High index
000000r 1               PREG			=	BIOS_PG0+2	;Temp Status reg
000000r 1               SREG			=	BIOS_PG0+3	;Temp Stack ptr
000000r 1               YREG			=	BIOS_PG0+4	;Temp Y reg
000000r 1               XREG			=	BIOS_PG0+5	;Temp X reg
000000r 1               AREG			=	BIOS_PG0+6	;Temp A reg
000000r 1               ;
000000r 1               ;	- 6551 IRQ handler pointers and status
000000r 1               ICNT			=	BIOS_PG0+7	;Input buffer count
000000r 1               IHEAD			=	BIOS_PG0+8	;Input buffer head pointer
000000r 1               ITAIL			=	BIOS_PG0+9	;Input buffer tail pointer
000000r 1               OCNT			=	BIOS_PG0+10	;Output buffer count
000000r 1               OHEAD			=	BIOS_PG0+11	;Output buffer head pointer
000000r 1               OTAIL			=	BIOS_PG0+12	;Output buffer tail pointer
000000r 1               STTVAL		=	BIOS_PG0+13	;6551 BIOS status byte
000000r 1               ;
000000r 1               ;	- Real-Time Clock variables
000000r 1               TICKS			=	BIOS_PG0+14	;# timer countdowns for 1 second (250)
000000r 1               SECS			=	BIOS_PG0+15	;Seconds: 0-59
000000r 1               MINS			=	BIOS_PG0+16	;Minutes: 0-59
000000r 1               HOURS			=	BIOS_PG0+17	;Hours: 0-23
000000r 1               DAYSL			=	BIOS_PG0+18	;Days: (2 bytes) 0-65535 >179 years
000000r 1               DAYSH			=	BIOS_PG0+19	;High order byte
000000r 1               ;
000000r 1               ;	- Delay Timer variables
000000r 1               MSDELAY		=	BIOS_PG0+20	;Timer delay countdown byte (255 > 0)
000000r 1               MATCH			=	BIOS_PG0+21	;Delay Match flag, $FF is set, $00 is cleared
000000r 1               SETIM			=	BIOS_PG0+22	;Set timeout for delay routines - BIOS use only
000000r 1               DELLO			=	BIOS_PG0+23	;Delay value BIOS use only
000000r 1               DELHI			=	BIOS_PG0+24	;Delay value BIOS use only
000000r 1               XDL				=	BIOS_PG0+25	;XL Delay count
000000r 1               STVVAL		=	BIOS_PG0+26	;Status for VIA IRQ flags
000000r 1               ;
000000r 1               ;	- I/O port variables
000000r 1               IO_DIR		=	BIOS_PG0+27	;I/O port direction temp
000000r 1               IO_IN			=	BIOS_PG0+28	;I/O port Input temp
000000r 1               IO_OUT		=	BIOS_PG0+29	;I/O port Output temp
000000r 1               ;
000000r 1               ; - Xmodem variables
000000r 1               XMFLAG		=	BIOS_PG0+30	;Xmodem transfer active flag
000000r 1               SPARE_B0	=	BIOS_PG0+31	;Spare BIOS page zero byte
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               ;Character input buffer address: $0200-$027F - 128 bytes
000000r 1               ;Character output buffer address: $0280-$02FF - 128 bytes
000000r 1               ;Managed by full-duplex IRQ service routine
000000r 1               ;
000000r 1               IBUF			=	$0200	;INPUT BUFFER  128 BYTES - BIOS use only
000000r 1               OBUF			=	$0280	;OUTPUT BUFFER 128 BYTES - BIOS use only
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               SOFTVEC		=	$0300	;Start of soft vectors
000000r 1               ;
000000r 1               ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM
000000r 1               ; The soft vectors are structured to allow inserting additional routines either before
000000r 1               ; or after the core routines. This allows flexibility and changing of routine priority
000000r 1               ;
000000r 1               ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
000000r 1               ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
000000r 1               ; returns to the ROM handler for each. The following 2 vectors are the cold and warm
000000r 1               ; entry points for the Monitor. After the basic initialization, the monitor is entered
000000r 1               ;
000000r 1               ;The following vector set allows inserts for any of the above vectors
000000r 1               ; there are a total of 8 Inserts which occupy 16 bytes. They can be used as required
000000r 1               ; note that the first two are used for the 6522 timer routines
000000r 1               ;
000000r 1               NMIVEC0		=	SOFTVEC	;NMI Interrupt Vector 0
000000r 1               BRKVEC0		=	SOFTVEC+2	;BRK Interrupt Vector 0
000000r 1               IRQVEC0		=	SOFTVEC+4	;INTERRUPT VECTOR 0
000000r 1               ;
000000r 1               NMIRTVEC0	=	SOFTVEC+6	;NMI Return Handler 0
000000r 1               BRKRTVEC0	=	SOFTVEC+8	;BRK Return Handler 0
000000r 1               IRQRTVEC0	=	SOFTVEC+10	;IRQ Return Handler 0
000000r 1               ;
000000r 1               CLDMNVEC0	=	SOFTVEC+12	;Cold Monitor Entry Vector 0
000000r 1               WRMMNVEC0	=	SOFTVEC+14	;Warm Monitor Entry Vector 0
000000r 1               ;
000000r 1               VECINSRT0	=	SOFTVEC+16	;1st Vector Insert (Timer support)
000000r 1               VECINSRT1	=	SOFTVEC+18	;1st Vector Insert (Timer support)
000000r 1               VECINSRT2	=	SOFTVEC+20	;1st Vector Insert
000000r 1               VECINSRT3	=	SOFTVEC+22	;1st Vector Insert
000000r 1               VECINSRT4	=	SOFTVEC+24	;1st Vector Insert
000000r 1               VECINSRT5	=	SOFTVEC+26	;1st Vector Insert
000000r 1               VECINSRT6	=	SOFTVEC+28	;1st Vector Insert
000000r 1               VECINSRT7	=	SOFTVEC+30	;1st Vector Insert
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               SOFTCFG		= SOFTVEC+32	;Start of hardware config parameters
000000r 1               ;
000000r 1               ;Soft Config values below are loaded from ROM and are the default I/O setup
000000r 1               ;configuration data that the INIT_65xx routines use. As a result, you can write a
000000r 1               ;routine to change the I/O configuration data and use the standard ROM routines
000000r 1               ;to initialize the I/O without restarting or changing ROM. A Reset (cold or coded)
000000r 1               ;will reinitialize the I/O with the ROM default I/O configuration
000000r 1               ;
000000r 1               ;There are a total of 32 Bytes configuration data reserved starting at $0320
000000r 1               ;
000000r 1               LOAD_6551	=	SOFTCFG	;6551 SOFT config data start
000000r 1               LOAD_6522	=	SOFTCFG+2	;6522 SOFT config data start
000000r 1               ;
000000r 1               ;Defaults for RTC ticks - number of IRQs for 1 second
000000r 1               DF_TICKS	=	250	;clock timer set for 4 milliseconds, so 250 x 4ms = 1 second
000000r 1               ;
000000r 1               ; Search Buffer is 16 bytes in length
000000r 1               ; Used to hold search string for text and hex data
000000r 1               SRCHBUFF	=	$340	;Located in Page $03 following HW config data
000000r 1               ;
000000r 1               ; Xmodem/CRC Loader also provides Motorola S19 Record sense and load
000000r 1               ; Designed to handle the S19 records from the WDC Assembler/Linker package
000000r 1               ; This requires a 44 byte buffer to parse each valid S1 record
000000r 1               ; Located just before the 132 Byte Xmodem frame buffer
000000r 1               ; There are a total of 176 bytes of Buffer associated with the Xmodem/CRC Loader
000000r 1               ;
000000r 1               ; Valid S-record headers are "S1" and "S9"
000000r 1               ; For S1, the maximum length is "19" hex. The last S1 record can be less
000000r 1               ; S9 record is always the last record with no data
000000r 1               ; WDC Linker also appends a CR/LF to the end of each record for a total 44 bytes
000000r 1               ;
000000r 1               SRBUFF		=	$0350	;Start of Motorola S-record buffer, 44 bytes in length
000000r 1               ;
000000r 1               ; Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked
000000r 1               ; for proper header and frame number, CRC-16 on the data, then moved to user RAM
000000r 1               ;
000000r 1               RBUFF			=	$037C	;Xmodem temp 132 byte receive buffer
000000r 1               ;
000000r 1               ;Additional Xmodem variables, etc.
000000r 1               ;
000000r 1               ; XMODEM Control Character Constants
000000r 1               SOH				=	$01	;Start of Block Header
000000r 1               EOT				=	$04	;End of Text marker
000000r 1               ACK				=	$06	;Good Block Acknowledge
000000r 1               NAK				=	$15	;Bad Block acknowledged
000000r 1               CAN				=	$18	;Cancel character
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               ;
000000r 1               BURN_BYTE	=	$1000	;Location in RAM for BYTE write routine
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               ;I/O Page Base Address
000000r 1               IOPAGE		=	$FE00
000000r 1               ;
000000r 1               ;VIA device address:
000000r 1               Via1Base	=  $A000    	;65C22 VIA base address here
000000r 1               Via1PRB		=  Via1Base+0	;Port B I/O register
000000r 1               Via1PRA		=  Via1Base+1	;Port A I/O register
000000r 1               Via1DDRB	=  Via1Base+2	;Port B data direction
000000r 1               Via1DDRA  =  Via1Base+3	;Port A data direction
000000r 1               Via1T1CL  =  Via1Base+4	;Timer 1 Low byte count
000000r 1               Via1T1CH  =  Via1Base+5	;Timer 1 High byte count
000000r 1               Via1T1LL  =  Via1Base+6	;Timer 1 Low byte latch
000000r 1               Via1TALH  =  Via1Base+7	;Timer 1 High byte latch
000000r 1               Via1T2CL  =  Via1Base+8	;Timer 2 Low byte count/latch
000000r 1               Via1T2CH  =  Via1Base+9	;Timer 2 High byte count
000000r 1               Via1SR    =  Via1Base+10	;Shift Register
000000r 1               Via1ACR   =  Via1Base+11	;Aux control register
000000r 1               Via1PCR   =  Via1Base+12	;Peripheral control register
000000r 1               Via1IFR   =  Via1Base+13	;Interrupt flag register
000000r 1               Via1IER   =  Via1Base+14	;Interrupt enable register
000000r 1               Via1PRA1  =  Via1Base+15	;Port A echo register
000000r 1               ;
000000r 1               ;ACIA device address:
000000r 1               SIOBase		=	$9000	;6551 Base HW address
000000r 1               SIODAT		=	SIOBase+0	;ACIA data register
000000r 1               SIOSTAT		=	SIOBase+1	;ACIA status register
000000r 1               SIOCOM		=	SIOBase+2 ;ACIA command register
000000r 1               SIOCON		=	SIOBase+3 ;ACIA control register
000000r 1               ;
000000r 1               ;******************************************************************************
000000r 1               ;					.ORG $E000    ;6KB reserved for monitor $E000 through $F7FF
000000r 1               ;******************************************************************************
000000r 1               ;START OF MONITOR CODE
000000r 1                               .segment "BIOS"
000000r 1               ;
000000r 1               ;*******************************************
000000r 1               ;*                C02 Monitor              *
000000r 1               ;*******************************************
000000r 1               ;*  This is the Monitor Cold start vector  *
000000r 1               ;*******************************************
000000r 1  A9 14        MONITOR		LDA	#$14	;Get intro msg / BEEP
000002r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000005r 1               ;
000005r 1               ;*******************************************
000005r 1               ;*           Command input loop            *
000005r 1               ;*******************************************
000005r 1               ;*  This in the Monitor Warm start vector  *
000005r 1               ;*******************************************
000005r 1  A2 FF        WRM_MON		LDX	#$FF	;Initialize Stack pointer
000007r 1  9A           					TXS	;Xfer to stack
000008r 1  64 D5        					STZ	CMDFLAG	;Clear Command flag
00000Ar 1  A9 16        					LDA	#$16	;Get prompt msg
00000Cr 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00000Fr 1               ;
00000Fr 1  20 rr rr     CMON			JSR	RDCHAR	;Wait for keystroke (converts to upper-case)
000012r 1  A2 1D        					LDX	#MONTAB-MONCMD-1	;Get command list count
000014r 1  DD rr rr     CMD_LP		CMP	MONCMD,X	;Compare to command list
000017r 1  D0 0D        					BNE	CMD_DEC	;Check for next command and loop
000019r 1  48           					PHA	;Save keystroke
00001Ar 1  8A           					TXA	;Xfer Command index to A reg
00001Br 1  0A           					ASL	A	;Multiply keystroke value by 2
00001Cr 1  AA           					TAX	;Get monitor command processor address from table MONTAB
00001Dr 1  68           					PLA	;Restore keystroke (some commands send keystroke to terminal)
00001Er 1  20 rr rr     					JSR	DOCMD	;Call selected monitor command processor as a subroutine
000021r 1  80 E2        					BRA	WRM_MON	;Command processed, branch and wait for next command
000023r 1  7C rr rr     DOCMD			JMP	(MONTAB,X)	;Execute CMD from Table
000026r 1               ;
000026r 1  CA           CMD_DEC		DEX	;Decrement index count
000027r 1  10 EB        					BPL	CMD_LP	;If more to check, loop back
000029r 1  20 rr rr     					JSR	BEEP	;Beep for error,
00002Cr 1  80 E1        					BRA	CMON	;re-enter monitor
00002Er 1               ;
00002Er 1               ;***********************************************
00002Er 1               ;* Basic Subroutines used by multiple routines *
00002Er 1               ;***********************************************
00002Er 1               ;
00002Er 1               ;ASC2BIN subroutine: Convert 2 ASCII HEX digits to a binary (byte) value
00002Er 1               ;Enter: A register = high digit, Y register = low digit
00002Er 1               ;Return: A register = binary value
00002Er 1  20 rr rr     ASC2BIN		JSR	BINARY	;Convert high digit to 4-bit nibble
000031r 1  0A           					ASL	A	;Shift to high nibble
000032r 1  0A           					ASL	A
000033r 1  0A           					ASL	A
000034r 1  0A           					ASL	A
000035r 1  85 D2        					STA	TEMP1	;Store it in temp area
000037r 1  98           					TYA	;Get Low digit
000038r 1  20 rr rr     					JSR	BINARY	;Convert low digit to 4-bit nibble
00003Br 1  05 D2        					ORA	TEMP1	;OR in the high nibble
00003Dr 1  60           					RTS	;Return to caller
00003Er 1               ;
00003Er 1  38           BINARY		SEC	;Set carry for subtraction
00003Fr 1  E9 30        					SBC	#$30	;Subtract $30 from ASCII HEX digit
000041r 1  C9 0A        					CMP	#$0A	;Check for result < 10
000043r 1  90 02        					BCC	BNOK	;Branch if 0-9
000045r 1  E9 07        					SBC	#$07	;Else, subtract 7 for A-F
000047r 1  60           BNOK			RTS	;Return to caller
000048r 1               ;
000048r 1               ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
000048r 1               ;Enter: A register contains byte value to convert
000048r 1               ;Return: A register = high digit, Y register = low digit
000048r 1  48           BIN2ASC		PHA	;Save A Reg on stack
000049r 1  29 0F        					AND	#$0F	;Mask off high nibble
00004Br 1  20 rr rr     					JSR	ASCII	;Convert nibble to ASCII HEX digit
00004Er 1  A8           					TAY	;Move to Y Reg
00004Fr 1  68           					PLA	;Get character back from stack
000050r 1  4A           					LSR	A	;Shift high nibble to lower 4 bits
000051r 1  4A           					LSR	A
000052r 1  4A           					LSR	A
000053r 1  4A           					LSR	A
000054r 1               ;
000054r 1  C9 0A        ASCII			CMP	#$0A	;Check for 10 or less
000056r 1  90 03        					BCC	ASOK	;Branch if less than 10
000058r 1  18           					CLC	;Clear carry for addition
000059r 1  69 07        					ADC	#$07	;Add $07 for A-F
00005Br 1  69 30        ASOK			ADC	#$30	;Add $30 for ASCII
00005Dr 1  60           					RTS	;Return to caller
00005Er 1               ;
00005Er 1               ;HEX2ASC - Accepts 16-bit Hexadecimal value and converts to an ASCII decimal string
00005Er 1               ;Input is via the A and Y registers and output is up to 5 ASCII digits in DATABUFF
00005Er 1               ;The High Byte is in the Y register and Low Byte is in the A register
00005Er 1               ;Output data is placed in variable DATABUFF and terminated with an null character
00005Er 1               ;PROMPTR routine is used to print the ASCII decimal value
00005Er 1               ;Routine based on Michael Barry's code. Saved many bytes ;-)
00005Er 1               ;
00005Er 1  85 BC        HEX2ASC		STA	BINVALL	;Save Low byte
000060r 1  84 BD        					STY	BINVALH	;Save High byte
000062r 1  A2 05        					LDX	#5	;Get ASCII buffer offset
000064r 1  74 B4        					STZ	DATABUFF,X	;Zero last buffer byte for null end
000066r 1               ;
000066r 1  A9 00        CNVERT		LDA	#$00	;Clear remainder
000068r 1  A0 10        					LDY	#16	;Set loop count for 16-bits
00006Ar 1               ;
00006Ar 1  C9 05        DVLOOP		CMP	#$05	;Partial remainder >= 10/2
00006Cr 1  90 02        					BCC	DVLOOP2	;Branch if less
00006Er 1  E9 05        					SBC	#$05	;Update partial, set carry
000070r 1               ;
000070r 1  26 BC        DVLOOP2		ROL	BINVALL	;Shift carry into dividend
000072r 1  26 BD        					ROL	BINVALH	;Which will be quotient
000074r 1  2A           					ROL	A	;Rotate A reg
000075r 1  88           					DEY	;Decrement count
000076r 1  D0 F2        					BNE	DVLOOP	;Branch back until done
000078r 1  09 30        					ORA	#$30	;Or in bits for ASCII
00007Ar 1               ;
00007Ar 1  CA           					DEX	;Decrement buffer index
00007Br 1  95 B4        					STA	DATABUFF,X	;Store value into buffer
00007Dr 1               ;
00007Dr 1  A5 BC        					LDA	BINVALL	;Get the Low byte
00007Fr 1  05 BD        					ORA	BINVALH	;OR in the High byte (check for zero)
000081r 1  D0 E3        					BNE	CNVERT	;Branch back until done
000083r 1  86 D2        					STX	TEMP1	;Save buffer offset
000085r 1               ;
000085r 1               ;Conversion is complete, get the string address,
000085r 1               ;add offset, then call prompt routine and return
000085r 1               ; note DATABUFF is fixed location in Page 0
000085r 1               ; carry flag need not be cleared as result can never
000085r 1               ; set flag after ADC instruction, Y Reg always zero
000085r 1               ;
000085r 1  A9 B4        					LDA	#<DATABUFF	;Get Low byte Address
000087r 1  65 D2        					ADC	TEMP1	;Add in buffer offset (no leading zeros)
000089r 1  A0 00        					LDY	#>DATABUFF	;Get High byte address
00008Br 1  4C rr rr     					JMP	PROMPTR	;Send to terminal and return
00008Er 1               ;
00008Er 1               ;SETUP subroutine: Request HEX address input from terminal
00008Er 1  20 rr rr     SETUP			JSR	CHROUT	;Send command keystroke to terminal
000091r 1  20 rr rr     					JSR	SPC	;Send [SPACE] to terminal
000094r 1  80 03        					BRA	HEXIN4	;Request a 0-4 digit HEX address input from terminal
000096r 1               ;
000096r 1               ;HEX input subroutines:
000096r 1               ;Request 1 to 4 ASCII HEX digits from terminal, then convert digits into a binary value
000096r 1               ;HEXIN2 - returns value in A reg and Y reg only (Y reg always $00)
000096r 1               ;HEXIN4 - returns values in A reg, Y reg and INDEXL/INDEXH
000096r 1               ;For 1 to 4 digits entered, HEXDATAH and HEXDATAL contain the output
000096r 1               ;Variable BUFIDX will contain the number of digits entered
000096r 1               ;HEX2 - Prints MSG# in A reg then calls HEXIN2
000096r 1               ;HEX4 - Prints MSG# in A reg then calls HEXIN4
000096r 1               ;
000096r 1  20 rr rr     HEX4			JSR	PROMPT	;Print MSG # from A reg
000099r 1  A2 04        HEXIN4		LDX	#$04	;Set for number of characters allowed
00009Br 1  20 rr rr     					JSR	HEXINPUT	;Convert digits
00009Er 1  84 C1        					STY	INDEXH	;Store to INDEXH
0000A0r 1  85 C0        					STA	INDEXL	;Store to INDEXL
0000A2r 1  60           					RTS	;Return to caller
0000A3r 1               ;
0000A3r 1  20 rr rr     HEX2			JSR	PROMPT	;Print MSG # from A reg
0000A6r 1  A2 02        HEXIN2		LDX	#$02	;Set for number of characters allowed
0000A8r 1               ;
0000A8r 1               ;HEXINPUT subroutine: request 1 to 4 HEX digits from terminal,
0000A8r 1               ;then convert ASCII HEX to HEX
0000A8r 1               ;Setup RDLINE subroutine parameters:
0000A8r 1  20 rr rr     HEXINPUT	JSR	DOLLAR	;Send "$" to console
0000ABr 1  20 rr rr     					JSR	RDLINE	;Request ASCII HEX input from terminal
0000AEr 1  F0 28        					BEQ	HINEXIT	;Exit if none (Z flag already set)
0000B0r 1  64 BA        					STZ	HEXDATAH	;Clear Upper HEX byte
0000B2r 1  64 BB        					STZ	HEXDATAL	;Clear Lower HEX byte
0000B4r 1  A0 02        					LDY	#$02	;Set index for 2 bytes
0000B6r 1  5A           ASCLOOP		PHY	;Save it to stack
0000B7r 1  B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
0000B9r 1  A8           					TAY	;Xfer to Y Reg (LSD)
0000BAr 1  CA           					DEX	;Decrement input count
0000BBr 1  F0 04        					BEQ	NO_UPNB	;Branch if no upper nibble
0000BDr 1  B5 AF        					LDA	INBUFF-1,X	;Read ASCII digit from buffer
0000BFr 1  80 02        					BRA	DO_UPNB	;Branch to include upper nibble
0000C1r 1  A9 30        NO_UPNB		LDA	#$30	;Load ASCII "0" (MSD)
0000C3r 1  20 rr rr     DO_UPNB		JSR	ASC2BIN	;Convert ASCII digits to binary value
0000C6r 1  7A           					PLY	;Get index from stack
0000C7r 1  99 B9 00     					STA	HEXDATAH-1,Y	;Write byte to indexed HEX input buffer location
0000CAr 1  E0 00        					CPX	#$00	;Any more digits?
0000CCr 1  F0 04        					BEQ	HINDONE	;If not, exit
0000CEr 1  88           					DEY	;Else, decrement to next byte set
0000CFr 1  CA           					DEX	;Decrement index count
0000D0r 1  D0 E4        					BNE	ASCLOOP	;Loop back for next byte
0000D2r 1  A4 BA        HINDONE		LDY	HEXDATAH	;Get High Byte
0000D4r 1  A5 BB        					LDA	HEXDATAL	;Get Low Byte
0000D6r 1  A6 CE        					LDX	BUFIDX	;Get input count (Z flag)
0000D8r 1  60           HINEXIT		RTS	;And return to caller
0000D9r 1               ;
0000D9r 1               ;Routines to update pointers for memory operations
0000D9r 1               ;
0000D9r 1               ;UPD_STL subroutine: Increments Source and Target pointers
0000D9r 1               ;UPD_TL subroutine: Increments Target pointers only
0000D9r 1               ; then drops into decrement length pointer. Used by multiple commands
0000D9r 1  E6 C8        UPD_STL		INC	SRCL	;Increment source low byte
0000DBr 1  D0 02        					BNE	UPD_TL	;Check for rollover
0000DDr 1  E6 C9        					INC	SRCH	;Increment source high byte
0000DFr 1  E6 CA        UPD_TL		INC	TGTL	;Increment target low byte
0000E1r 1  D0 02        					BNE	DECLEN	;Check for rollover
0000E3r 1  E6 CB        					INC	TGTH	;Increment target high byte
0000E5r 1               ;
0000E5r 1               ;DECLEN subroutine: decrement 16-bit variable LENL/LENH
0000E5r 1  A5 CC        DECLEN		LDA	LENL	;Get length low byte
0000E7r 1  D0 02        					BNE	SKP_LENH	;Test for LENL = zero
0000E9r 1  C6 CD        					DEC	LENH	;Else decrement length high byte
0000EBr 1  C6 CC        SKP_LENH	DEC	LENL	;Decrement length low byte
0000EDr 1  60           					RTS	;Return to caller
0000EEr 1               ;
0000EEr 1               ;DECINDEX subroutine: decrement 16 bit variable INDEXL/INDEXH
0000EEr 1  A5 C0        DECINDEX	LDA	INDEXL	;Get index low byte
0000F0r 1  D0 02        					BNE	SKP_IDXH	;Test for INDEXL = zero
0000F2r 1  C6 C1        					DEC	INDEXH	;Decrement index high byte
0000F4r 1  C6 C0        SKP_IDXH	DEC	INDEXL	;Decrement index low byte
0000F6r 1  60           					RTS	;Return to caller
0000F7r 1               ;
0000F7r 1               ;INCINDEX subroutine: increment 16 bit variable INDEXL/INDEXH
0000F7r 1  E6 C0        INCINDEX	INC	INDEXL	;Increment index low byte
0000F9r 1  D0 02        					BNE	SKP_IDX	;If not zero, skip high byte
0000FBr 1  E6 C1        					INC	INDEXH	;Increment index high byte
0000FDr 1  60           SKP_IDX		RTS	;Return to caller
0000FEr 1               ;
0000FEr 1               ;Output routines for formatting, backspaces, CR/LF, BEEP, etc.
0000FEr 1               ; all routines preserve the A reg on exit.
0000FEr 1               ;
0000FEr 1               ;BEEP subroutine: Send ASCII [BELL] to terminal
0000FEr 1  48           BEEP			PHA	;Save A reg on Stack
0000FFr 1  A9 07        					LDA	#$07	;Get ASCII [BELL] to terminal
000101r 1  80 2E        					BRA	SENDIT	;Branch to send
000103r 1               ;
000103r 1               ;BSOUT subroutine: send a Backspace to terminal
000103r 1  20 rr rr     BSOUT			JSR	BSOUT2	;Send an ASCII backspace
000106r 1  20 rr rr     					JSR	SPC	;Send space to clear out character
000109r 1  48           BSOUT2		PHA	;Save character in A reg
00010Ar 1  A9 08        					LDA	#$08	;Send another Backspace to return
00010Cr 1  80 23        BRCHOUT		BRA	SENDIT	;Branch to send
00010Er 1               ;
00010Er 1  20 rr rr     BSOUT3T		JSR	BSOUT2	;Send a Backspace 3 times
000111r 1  20 rr rr     BSOUT2T		JSR	BSOUT2	;Send a Backspace 2 times
000114r 1  80 F3        					BRA	BSOUT2	;Send a Backspace and return
000116r 1               ;
000116r 1               ;SPC subroutines: Send a Space to terminal 1,2 or 4 times
000116r 1  20 rr rr     SPC4			JSR	SPC2	;Send 4 Spaces to terminal
000119r 1  20 rr rr     SPC2			JSR	SPC	;Send 2 Spaces to terminal
00011Cr 1  48           SPC				PHA	;Save character in A reg
00011Dr 1  A9 20        					LDA	#$20	;Get ASCII Space
00011Fr 1  80 10        					BRA	SENDIT	;Branch to send
000121r 1               ;
000121r 1               ;DOLLAR subroutine: Send "$" to terminal
000121r 1  48           DOLLAR		PHA	;Save A reg on STACK
000122r 1  A9 24        					LDA	#$24	;Get ASCII "$"
000124r 1  80 0B        					BRA	SENDIT	;Branch to send
000126r 1               ;
000126r 1               ;Send CR,LF to terminal
000126r 1  20 rr rr     CR2				JSR	CROUT	;Send CR,LF to terminal
000129r 1  48           CROUT			PHA	;Save A reg
00012Ar 1  A9 0D        					LDA	#$0D	;Get ASCII Return
00012Cr 1  20 rr rr     					JSR	CHROUT	;Send to terminal
00012Fr 1  A9 0A        					LDA	#$0A	;Get ASCII Linefeed
000131r 1  20 rr rr     SENDIT		JSR	CHROUT	;Send to terminal
000134r 1  68           					PLA	;Restore A reg
000135r 1  60           					RTS	;Return to caller
000136r 1               ;
000136r 1               ;GLINE subroutine: Send a horizontal line to terminal
000136r 1               ; used by memory display only, does not preserve any registers
000136r 1               ;
000136r 1  A2 4F        GLINE			LDX	#$4F	;Load index for 79 decimal
000138r 1  A9 7E        					LDA	#$7E	;Get "~" character
00013Ar 1  20 rr rr     GLINEL		JSR	CHROUT	;Send to terminal (draw a line)
00013Dr 1  CA           					DEX	;Decrement count
00013Er 1  D0 FA        					BNE	GLINEL	;Branch back until done
000140r 1  60           					RTS	;Return to caller
000141r 1               ;
000141r 1               ;Routines to output 8/16-bit Binary Data and Ascii characters
000141r 1               ;
000141r 1               ;PRASC subroutine: Print A-reg as ASCII, else print "."
000141r 1               ;Printable ASCII byte values = $20 through $7E
000141r 1  C9 7F        PRASC			CMP	#$7F	;Check for first 128
000143r 1  B0 04        					BCS	PERIOD	;If = or higher, branch
000145r 1  C9 20        					CMP	#$20	;Check for control characters
000147r 1  B0 02        					BCS	ASCOUT	;If space or higher, branch and print
000149r 1  A9 2E        PERIOD		LDA	#$2E	;Else, print a "."
00014Br 1  4C rr rr     ASCOUT		JMP	CHROUT	;Send byte in A-Reg, then return
00014Er 1               ;
00014Er 1               ;PRBYTE subroutine:
00014Er 1               ; Converts a single Byte to 2 HEX ASCII characters and sends to console
00014Er 1               ; on entry, A reg contains the Byte to convert/send
00014Er 1               ; Register contents are preserved on entry/exit
00014Er 1  48           PRBYTE		PHA	;Save A register
00014Fr 1  5A           					PHY	;Save Y register
000150r 1  20 rr rr     PRBYT2		JSR	BIN2ASC	;Convert A reg to 2 ASCII Hex characters
000153r 1  20 rr rr     					JSR	CHROUT	;Print high nibble from A reg
000156r 1  98           					TYA	;Transfer low nibble to A reg
000157r 1  20 rr rr     					JSR	CHROUT	;Print low nibble from A reg
00015Ar 1  7A           					PLY	;Restore Y Register
00015Br 1  68           					PLA	;Restore A Register
00015Cr 1  60           					RTS	;And return to caller
00015Dr 1               ;
00015Dr 1               ;PRINDEX	subroutine:
00015Dr 1               ; Used by Memory Dump and Text Entry routines
00015Dr 1               ; Prints a $ sign followed by the current value of INDEXH/L
00015Dr 1  20 rr rr     PRINDEX		JSR	DOLLAR	;Print a $ sign
000160r 1  A5 C1        					LDA	INDEXH	;Get Index high byte
000162r 1  A4 C0        					LDY	INDEXL	;Get Index low byte
000164r 1               ;
000164r 1               ;PRWORD	subroutine:
000164r 1               ;	Converts a 16-bit word to 4 HEX ASCII characters and sends to console
000164r 1               ; on entry, A reg contains High Byte, Y reg contains Low Byte
000164r 1               ; Register contents are preserved on entry/exit
000164r 1  48           PRWORD		PHA	;Save A register
000165r 1  5A           					PHY	;Save Y register
000166r 1  20 rr rr     					JSR	PRBYTE	;Convert and print one HEX character (00-FF)
000169r 1  98           					TYA	;Get Low byte value
00016Ar 1  80 E4        					BRA	PRBYT2	;Finish up Low Byte and exit
00016Cr 1               ;
00016Cr 1               ;RDLINE subroutine: Store keystrokes in buffer until [RETURN] key it struck
00016Cr 1               ;Used only for Hex entry, so only (0-9,A-F) are accepted entries
00016Cr 1               ;Lower-case alpha characters are converted to upper-case.
00016Cr 1               ;On entry, X reg = buffer length. On exit, X reg = buffer count
00016Cr 1               ;[BACKSPACE] key removes keystrokes from buffer.
00016Cr 1               ;[ESCAPE] key aborts then re-enters monitor.
00016Cr 1  86 CF        RDLINE		STX	BUFLEN	;Store buffer length
00016Er 1  64 CE        					STZ	BUFIDX	;Zero buffer index
000170r 1  20 rr rr     RDLOOP		JSR	RDCHAR	;Get character from terminal, convert LC2UC
000173r 1  C9 1B        					CMP	#$1B	;Check for ESC key
000175r 1  F0 36        					BEQ	RDNULL	;If yes, exit back to Monitor
000177r 1  C9 0D        NOTESC		CMP	#$0D	;Check for C/R
000179r 1  F0 2B        					BEQ	EXITRD	;Exit if yes
00017Br 1  C9 08        					CMP	#$08	;Check for Backspace
00017Dr 1  F0 1C        					BEQ	RDBKSP	;If yes handle backspace
00017Fr 1  C9 30        TSTHEX		CMP	#$30	;Check for '0' or higher
000181r 1  90 0A        					BCC	INPERR	;Branch to error if less than '0'
000183r 1  C9 47        					CMP	#$47	;Check for 'G' ('F'+1)
000185r 1  B0 06        					BCS	INPERR	;Branch to error if 'G' or higher
000187r 1  A6 CE        FULTST		LDX	BUFIDX	;Get the current buffer index
000189r 1  E4 CF        					CPX	BUFLEN	;Compare to length for space
00018Br 1  90 05        					BCC	STRCHR	;Branch to store in buffer
00018Dr 1  20 rr rr     INPERR		JSR	BEEP	;Else, error, send Bell to terminal
000190r 1  80 DE        					BRA	RDLOOP	;Branch back to RDLOOP
000192r 1  95 B0        STRCHR		STA	INBUFF,X	;Store keystroke in buffer
000194r 1  20 rr rr     					JSR	CHROUT	;Send keystroke to terminal
000197r 1  E6 CE        					INC	BUFIDX	;Increment buffer index
000199r 1  80 D5        					BRA	RDLOOP	;Branch back to RDLOOP
00019Br 1  A5 CE        RDBKSP		LDA	BUFIDX	;Check if buffer is empty
00019Dr 1  F0 EE        					BEQ	INPERR	;Branch if yes
00019Fr 1  C6 CE        					DEC	BUFIDX	;Else, decrement buffer index
0001A1r 1  20 rr rr     					JSR	BSOUT	;Send Backspace to terminal
0001A4r 1  80 CA        					BRA	RDLOOP	;Loop back and continue
0001A6r 1  A6 CE        EXITRD		LDX	BUFIDX	;Get keystroke count (Z flag)
0001A8r 1  D0 0F        					BNE	AOK	;If data entered, normal exit
0001AAr 1  FF D5 0C     					BBS7	CMDFLAG,AOK	;Branch if CMD flag active
0001ADr 1  6C 0E 03     RDNULL		JMP	(WRMMNVEC0)	;Quit to Monitor warm start
0001B0r 1               ;
0001B0r 1               ;RDCHAR subroutine: Waits for a keystroke to be entered.
0001B0r 1               ; if keystroke is a lower-case alphabetical, convert it to upper-case
0001B0r 1  20 rr rr     RDCHAR		JSR	CHRIN	;Request keystroke input from terminal
0001B3r 1  C9 61        					CMP	#$61	;Check for lower case value range
0001B5r 1  90 02        					BCC	AOK	;Branch if < $61, control code/upper-case/numeric
0001B7r 1  E9 20        					SBC	#$20	;Subtract $20 to convert to upper case
0001B9r 1  60           AOK				RTS	;Character received, return to caller
0001BAr 1               ;
0001BAr 1               ;Continue routine, called by commands to confirm execution
0001BAr 1               ;when No is confirmed, return address removed from stack
0001BAr 1               ;and the exit goes back to the monitor loop.
0001BAr 1               ;Short version prompts for (Y/N) only.
0001BAr 1  A9 00        CONTINUE	LDA	#$00	;Get msg "cont? (Y/N)" to terminal
0001BCr 1  80 02        					BRA	SH_CONT	;Branch down
0001BEr 1  A9 01        CONTINUE2	LDA	#$01	;Get short msg "(Y/N)" only
0001C0r 1  20 rr rr     SH_CONT		JSR	PROMPT	;Send to terminal
0001C3r 1  20 rr rr     TRY_AGN		JSR	RDCHAR	;Get keystroke from terminal
0001C6r 1  C9 59        					CMP	#$59	;"Y" key?
0001C8r 1  F0 0B        					BEQ	DOCONT	;if yes, continue/exit
0001CAr 1  C9 4E        					CMP	#$4E	;if "N", quit/exit
0001CCr 1  F0 05        					BEQ	DONTCNT	;Return if not ESC
0001CEr 1  20 rr rr     					JSR	BEEP	;Send Beep to console
0001D1r 1  80 F0        					BRA	TRY_AGN	;Loop back, try again
0001D3r 1  68           DONTCNT		PLA	;Else remove return address
0001D4r 1  68           					PLA	;discard it,
0001D5r 1  60           DOCONT		RTS	;Return
0001D6r 1               ;
0001D6r 1               ;******************************
0001D6r 1               ;* Monitor command processors *
0001D6r 1               ;******************************
0001D6r 1               ;
0001D6r 1               ;[,] Delay Setup Routine
0001D6r 1               ;	This routine gets hex input via the console
0001D6r 1               ;	- first is a hex byte ($00-$FF) for the millisecond count
0001D6r 1               ;	- second is a hex word ($0000-$FFFF) for the delay multiplier
0001D6r 1               ;		these are stored in variables SETIM, DELLO/DELHI
0001D6r 1               ;
0001D6r 1  A9 17        SET_DELAY	LDA	#$17	;Get millisecond delay message
0001D8r 1  20 rr rr     					JSR	HEX2	;Use short cut version for print and input
0001DBr 1  85 F6        					STA	SETIM	;Else store millisecond count in variable
0001DDr 1  A9 18        GETMULT		LDA	#$18	;Get Multiplier message
0001DFr 1  20 rr rr     					JSR	HEX4	;Use short cut version for print and input
0001E2r 1  85 F7        					STA	DELLO	;Store Low byte
0001E4r 1  84 F8        					STY	DELHI	;Store High byte
0001E6r 1  60           					RTS	;Return to caller
0001E7r 1               ;
0001E7r 1               ;[\] Execute XL Delay
0001E7r 1               ; Get an 8-bit value for extra long delay, execute is entered
0001E7r 1  A9 19        SET_XLDLY	LDA	#$19	;Get XL Loop message
0001E9r 1  20 rr rr     					JSR	HEX2	;Use short cut version for print and input
0001ECr 1  85 F9        					STA	XDL	;Save delay value
0001EEr 1  A9 0D        					LDA	#$0D	;Get ASCII C/R
0001F0r 1  20 rr rr     					JSR	CHROUT	;Send C/R (shows delay has been executed, no L/F)
0001F3r 1  4C rr rr     					JMP	EXE_XLDLY	;Execute Extra Long delay loop
0001F6r 1               ;
0001F6r 1               ;[(] INIMACRO command: Initialize keystroke input buffer
0001F6r 1               ;initializes buffer head/tail pointers and resets buffer count to zero
0001F6r 1               ;input buffer appears empty so command macro starts at the head of the buffer
0001F6r 1  64 DD        INIMACRO	STZ	LPCNTL	;Zero Loop count low byte
0001F8r 1  64 DE        					STZ	LPCNTH	;Zero Loop count high byte
0001FAr 1  64 DF        					STZ	LPCNTF	;Zero Loop count flag
0001FCr 1               ;
0001FCr 1  A9 2D        LP_CNT_FL	LDA	#$2D	;Get Loop Count msg
0001FEr 1  20 rr rr     					JSR	PROMPT	;send to console
000201r 1  A9 01        					LDA	#$01	;Get short msg "(Y/N)" only
000203r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000206r 1  20 rr rr     					JSR	RDCHAR	;Get keystroke from terminal
000209r 1  C9 59        					CMP	#$59	;"Y" key?
00020Br 1  F0 09        					BEQ	DOLOOPS	;if yes, set loop flag
00020Dr 1  C9 4E        					CMP	#$4E	;if "N", quit/exit
00020Fr 1  F0 07        					BEQ	NOLOOPS	;if no, don't set loop flag
000211r 1  20 rr rr     					JSR	BEEP	;Neither y/n selected, sound bell
000214r 1  80 E6        					BRA	LP_CNT_FL	;Branch back, try again
000216r 1               ;
000216r 1  F7 DF        DOLOOPS		SMB7	LPCNTF	;Set high order bit of Loop flag
000218r 1  64 E7        NOLOOPS		STZ	ICNT	;Zero Input buffer count
00021Ar 1  64 E9        					STZ	ITAIL	;Zero Input buffer tail pointer
00021Cr 1  64 E8        MACINI		STZ	IHEAD	;Zero Input buffer head pointer
00021Er 1  60           DONEFILL	RTS	;Return to caller
00021Fr 1               ;
00021Fr 1               ;[)] RUNMACRO command: Run monitor command macro. This will indicate that there
00021Fr 1               ;are 128 keystrokes in the keystroke input buffer. The monitor will process these
00021Fr 1               ;as if they were received from the terminal (typed-in by the user). Because the
00021Fr 1               ;last keystroke stored in the keystroke buffer was ")", this will loop continuously
00021Fr 1               ;Use [BREAK] to exit macro
00021Fr 1  A9 7F        RUNMACRO	LDA	#$7F	;Set keystroke buffer tail pointer to $7F
000221r 1  85 E9        					STA	ITAIL	;Push tail pointer to end
000223r 1  1A           					INC	A	;Increment to $80 for buffer count (full)
000224r 1  85 E7        					STA	ICNT	;Make count show as full
000226r 1  7F DF 15     					BBR7	LPCNTF,NOLP_CNT	;If Loop flag clear, branch around it
000229r 1  E6 DD        					INC	LPCNTL	;Increment loops low byte
00022Br 1  D0 02        					BNE	SKP_LPC	;If not zero, skip high byte
00022Dr 1  E6 DE        					INC	LPCNTH	;Increment loops high byte
00022Fr 1  A9 2E        SKP_LPC		LDA	#$2E	;Get Loops msg
000231r 1  20 rr rr     					JSR	PROMPT	;Send to console
000234r 1  A5 DD        					LDA	LPCNTL	;Get Loop count low
000236r 1  A4 DE        					LDY	LPCNTH	;Get Loop count high
000238r 1  20 rr rr     					JSR	HEX2ASC	;Print Loop count
00023Br 1  20 rr rr     					JSR	CROUT	;Send C/R to console
00023Er 1  80 DC        NOLP_CNT	BRA	MACINI	;Zero Head pointer and exit
000240r 1               ;
000240r 1               ;[C] Compare one memory range to another and display any addresses which do not match
000240r 1               ;[M] Move routine uses this section for parameter input, then branches to MOVER below
000240r 1               ;[F] Fill routine uses this section for parameter input but requires a fill byte value
000240r 1               ;[CTRL-P] Program EEPROM uses this section for parameter input and to write the EEPROM
000240r 1               ;Uses source, target and length input parameters. errors in compare are shown in target space
000240r 1               ;
000240r 1  A9 05        FM_INPUT	LDA	#$05	;Send "val: " to terminal
000242r 1  20 rr rr     					JSR	HEX2	;Use short cut version for print and input
000245r 1  AA           					TAX	;Xfer fill byte to X reg
000246r 1  20 rr rr     					JSR	CONTINUE	;Handle continue prompt
000249r 1               ;
000249r 1               ;Memory fill routine: parameter gathered below with Move/Fill, then a jump to here
000249r 1               ;Xreg contains fill byte value
000249r 1  A5 CC        FILL_LP		LDA	LENL	;Get length low byte
00024Br 1  05 CD        					ORA	LENH	;OR in length high byte
00024Dr 1  F0 CF        					BEQ	DONEFILL	;Exit if zero
00024Fr 1  8A           					TXA	;Get fill byte
000250r 1  92 CA        					STA	(TGTL)	;Store in target location
000252r 1  20 rr rr     					JSR	UPD_TL	;Update Target/Length pointers
000255r 1  80 F2        					BRA	FILL_LP	;Loop back until done
000257r 1               ;
000257r 1               ;Compare/Move/Fill memory operations enter here, branches as required
000257r 1               ;
000257r 1  85 D3        CPMVFL		STA	TEMP2	;Save command character
000259r 1  20 rr rr     					JSR	CHROUT	;Print command character (C/M/F)
00025Cr 1  C9 46        					CMP	#$46	;Check for F - fill memory
00025Er 1  D0 0B        					BNE	PRGE_E	;If not continue normal parameter input
000260r 1  A9 03        					LDA	#$03	;Get msg " addr:"
000262r 1  80 12        					BRA	F_INPUT	;Branch to handle parameter input
000264r 1               ;
000264r 1               ;EEPROM wrte operation enters here
000264r 1               ;
000264r 1  A9 21        PROGEE		LDA	#$21	;Get PRG_EE msg
000266r 1  20 rr rr     					JSR	PROMPT	;send to terminal
000269r 1  64 D3        					STZ	TEMP2	;Clear (Compare/Fill/Move) / error flag
00026Br 1               ;
00026Br 1  A9 06        PRGE_E		LDA	#$06	;Send " src:" to terminal
00026Dr 1  20 rr rr     					JSR	HEX4	;Use short cut version for print and input
000270r 1  85 C8        					STA	SRCL	;Else, store source address in variable SRCL,SRCH
000272r 1  84 C9        					STY	SRCH	;Store high address
000274r 1  A9 07        					LDA	#$07	;Send " tgt:" to terminal
000276r 1  20 rr rr     F_INPUT		JSR	HEX4	;Use short cut version for print and input
000279r 1  85 CA        					STA	TGTL	;Else, store target address in variable TGTL,TGTH
00027Br 1  84 CB        					STY	TGTH	;Store high address
00027Dr 1  A9 04        					LDA	#$04	;Send " len:" to terminal
00027Fr 1  20 rr rr     					JSR	HEX4	;Use short cut version for print and input
000282r 1  85 CC        					STA	LENL	;ELSE, store length address in variable LENL,LENH
000284r 1  84 CD        					STY	LENH	;Store high address
000286r 1               ;
000286r 1               ; All input parameters for Source, Target and Length entered
000286r 1  A5 D3        					LDA	TEMP2	;Get Command character
000288r 1  C9 46        					CMP	#$46	;Check for fill memory
00028Ar 1  F0 B4        					BEQ	FM_INPUT	;Handle the remaining input
00028Cr 1  C9 43        					CMP	#$43	;Test for Compare
00028Er 1  F0 36        					BEQ	COMPLP	;Branch if yes
000290r 1  C9 4D        					CMP	#$4D	;Check for Move
000292r 1  F0 5B        					BEQ	MOVER	;Branch if yes
000294r 1               ;
000294r 1  A9 22        PROG_EE		LDA	#$22	;Get warning msg
000296r 1  20 rr rr     					JSR	PROMPT	;Send to console
000299r 1  20 rr rr     					JSR	CONTINUE2	;Prompt for y/n
00029Cr 1               ;
00029Cr 1               ;Programming of the EEPROM is now confirmed by user
00029Cr 1               ; This routine will copy the core move and test routine
00029Cr 1               ; from ROM to RAM, then call COMPLP to write and compare
00029Cr 1               ; as I/O can generate interrupts which point to ROM routines,
00029Cr 1               ; all interrupts must be disabled during the sequence.
00029Cr 1               ;
00029Cr 1               ;Send message to console for writing EEPROM
00029Cr 1  A9 23        					LDA	#$23	;Get write message
00029Er 1  20 rr rr     					JSR	PROMPT	;Send to console
0002A1r 1  A5 EA        OC_LOOP		LDA	OCNT	;Check output buffer count
0002A3r 1  D0 FC        					BNE	OC_LOOP	;Loop back until buffer sent
0002A5r 1               ;
0002A5r 1               ;Xfer byte write code to RAM for execution
0002A5r 1  A2 15        					LDX	#BYTE_WRE-BYTE_WRS+1	;Get length of byte write code
0002A7r 1  BD rr rr     BYTE_XFER	LDA	BYTE_WRS-1,X	;Get code
0002AAr 1  9D FF 0F     					STA	BURN_BYTE-1,X	;Write code to RAM
0002ADr 1  CA           					DEX	;Decrement index
0002AEr 1  D0 F7        					BNE	BYTE_XFER	;Loop back until done
0002B0r 1               ;
0002B0r 1  F7 D3        PROG_EEP	SMB7	TEMP2	;Set EEPROM write active mask
0002B2r 1  20 rr rr     					JSR	COMPLP	;Call routine to write/compare
0002B5r 1  6F D3 04     					BBR6	TEMP2,PRG_GOOD	;Skip down if no error
0002B8r 1  A9 25        					LDA	#$25	;Get Prog failed message
0002BAr 1  80 07        					BRA	BRA_PRMPT	;Branch to Prompt routine
0002BCr 1               ;
0002BCr 1  A9 24        PRG_GOOD	LDA	#$24	;Get completed message
0002BEr 1  20 rr rr     					JSR	PROMPT	;Send to console
0002C1r 1  A9 26        					LDA	#$26	;Get warning message for RTC and Reset
0002C3r 1  4C rr rr     BRA_PRMPT	JMP	PROMPT	;Send to console and exit
0002C6r 1               ;
0002C6r 1  A5 CC        COMPLP		LDA	LENL	;Get low byte of length
0002C8r 1  05 CD        					ORA	LENH	;OR in High byte of length
0002CAr 1  F0 71        					BEQ	QUITMV	;If zero, nothing to compare/write
0002CCr 1  7F D3 03     					BBR7	TEMP2,SKP_BURN	;Skip burn if bit 7 clear
0002CFr 1  20 00 10     					JSR	BURN_BYTE	;Else Burn a byte to EEPROM
0002D2r 1  B2 C8        SKP_BURN	LDA	(SRCL)	;Else load source
0002D4r 1  D2 CA        					CMP	(TGTL)	;Compare to source
0002D6r 1  F0 12        					BEQ	CMP_OK	;If compare is good, continue
0002D8r 1               ;
0002D8r 1  E7 D3        					SMB6	TEMP2	;Set bit 6 of TEMP2 flag (compare error)
0002DAr 1  20 rr rr     					JSR	SPC2	;Send 2 spaces
0002DDr 1  20 rr rr     					JSR	DOLLAR	;Print $ sign
0002E0r 1  A5 CB        					LDA	TGTH	;Get high byte of address
0002E2r 1  A4 CA        					LDY	TGTL	;Get Low byte of address
0002E4r 1  20 rr rr     					JSR	PRWORD	;Print word
0002E7r 1  20 rr rr     					JSR	SPC	;Add 1 space for formatting
0002EAr 1               ;
0002EAr 1  20 rr rr     CMP_OK		JSR	UPD_STL	;Update pointers
0002EDr 1  80 D7        					BRA	COMPLP	;Loop back until done
0002EFr 1               ;
0002EFr 1               ;Parameters for move memory entered and validated
0002EFr 1               ; now make decision on which direction to do the actual move
0002EFr 1               ; if overlapping, move from end to start, else from start to end
0002EFr 1  20 rr rr     MOVER			JSR	CONTINUE	;Prompt to continue move
0002F2r 1  38           					SEC	;Set carry flag for subtract
0002F3r 1  A5 CA        					LDA	TGTL	;Get target lo byte
0002F5r 1  E5 C8        					SBC	SRCL	;Subtract source lo byte
0002F7r 1  AA           					TAX	;Move to X reg temporarily
0002F8r 1  A5 CB        					LDA	TGTH	;Get target hi byte
0002FAr 1  E5 C9        					SBC	SRCH	;Subtract source hi byte
0002FCr 1  A8           					TAY	;Move to Y reg temporarily
0002FDr 1  8A           					TXA	;Xfer lo byte difference to A reg
0002FEr 1  C5 CC        					CMP	LENL	;Compare to lo byte length
000300r 1  98           					TYA	;Xfer hi byte difference to A reg
000301r 1  E5 CD        					SBC	LENH	;Subtract length lo byte
000303r 1  90 0F        					BCC	RIGHT	;If carry is clear, overwrite condition exists
000305r 1               ;Move memory block first byte to last byte, no overlap condition
000305r 1  A5 CC        MVNO_LP		LDA	LENL	;Get length low byte
000307r 1  05 CD        					ORA	LENH	;OR in length high byte
000309r 1  F0 32        					BEQ	QUITMV	;Exit if zero bytes to move
00030Br 1  B2 C8        					LDA	(SRCL)	;Load source data
00030Dr 1  92 CA        					STA	(TGTL)	;Store as target data
00030Fr 1  20 rr rr     					JSR	UPD_STL	;Update Source/Target/Length variables
000312r 1  80 F1        					BRA	MVNO_LP	;Branch back until length is zero
000314r 1               ;
000314r 1               ;Move memory block last byte to first byte
000314r 1               ; avoids overwrite in source/target overlap
000314r 1  A6 CD        RIGHT			LDX	LENH	;Get the length hi byte count
000316r 1  18           					CLC	;Clear carry flag for add
000317r 1  8A           					TXA	;Xfer High page to A reg
000318r 1  65 C9        					ADC	SRCH	;Add in source hi byte
00031Ar 1  85 C9        					STA	SRCH	;Store in source hi byte
00031Cr 1  18           					CLC	;Clear carry for add
00031Dr 1  8A           					TXA	;Xfer High page to A reg
00031Er 1  65 CB        					ADC	TGTH	;Add to target hi byte
000320r 1  85 CB        					STA	TGTH	;Store to target hi byte
000322r 1  E8           					INX	;Increment high page value for use below in loop
000323r 1  A4 CC        					LDY	LENL	;Get length lo byte
000325r 1  F0 0E        					BEQ	MVPG	;If zero no partial page to move
000327r 1  88           					DEY	;Else, decrement page byte index
000328r 1  F0 07        					BEQ	MVPAG	;If zero, no pages to move
00032Ar 1  B1 C8        MVPRT			LDA	(SRCL),Y	;Load source data
00032Cr 1  91 CA        					STA	(TGTL),Y	;Store to target data
00032Er 1  88           					DEY	;Decrement index
00032Fr 1  D0 F9        					BNE  MVPRT	;Branch back until partial page moved
000331r 1  B1 C8        MVPAG			LDA	(SRCL),Y	;Load source data
000333r 1  91 CA        					STA	(TGTL),Y	;Store to target data
000335r 1  88           MVPG			DEY	;Decrement page count
000336r 1  C6 C9        					DEC	SRCH	;Decrement source hi page
000338r 1  C6 CB        					DEC	TGTH	;Decrement target hi page
00033Ar 1  CA           					DEX	;Decrement page count
00033Br 1  D0 ED        					BNE	MVPRT	;Loop back until all pages moved
00033Dr 1  60           QUITMV		RTS	;Return to caller
00033Er 1               ;
00033Er 1  78           BYTE_WRS	SEI	;Disable interrupts
00033Fr 1  B2 C8        					LDA	(SRCL)	;Get source byte
000341r 1  92 CA        					STA	(TGTL)	;Write to target byte
000343r 1  B2 CA        					LDA	(TGTL)	;Read target byte (EEPROM)
000345r 1  29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
000347r 1  85 D4        BYTE_WLP	STA	TEMP3	;Store in Temp location
000349r 1  B2 CA        					LDA	(TGTL)	;Read target byte again (EEPROM)
00034Br 1  29 40        					AND	#%01000000	;Mask off bit 6 - toggle bit
00034Dr 1  C5 D4        					CMP	TEMP3	;Compare to last read (toggles if write mode)
00034Fr 1  D0 F6        					BNE	BYTE_WLP	;Branch back if not done
000351r 1  58           					CLI	;Re-enable interrupts
000352r 1  60           BYTE_WRE	RTS	;Return to caller
000353r 1               ;
000353r 1               ;[D] HEX/TEXT DUMP command:
000353r 1               ; Display in HEX followed by TEXT the contents of 256 consecutive memory addresses
000353r 1  F7 D5        MDUMP			SMB7	CMDFLAG	;Set Command flag
000355r 1  20 rr rr     					JSR	SETUP	;Request HEX address input from terminal
000358r 1  D0 08        					BNE	LINED	;Branch if new address entered (Z flag set already)
00035Ar 1  A5 C2        					LDA	TEMP1L	;Else, point to next consecutive memory page
00035Cr 1  85 C0        					STA	INDEXL	;address saved during last memory dump
00035Er 1  A5 C3        					LDA	TEMP1H	;xfer high byte of address
000360r 1  85 C1        					STA	INDEXH	;save in pointer
000362r 1  20 rr rr     LINED			JSR	DMPGR	;Send address offsets to terminal
000365r 1  20 rr rr     					JSR	GLINE	;Send horizontal line to terminal
000368r 1  20 rr rr     					JSR	CROUT	;Send CR,LF to terminal
00036Br 1  A2 10        					LDX	#$10	;Set line count for 16 rows
00036Dr 1  20 rr rr     DLINE			JSR	SPC4	;Send 4 Spaces to terminal
000370r 1  20 rr rr     					JSR	PRINDEX	;Print INDEX value
000373r 1  20 rr rr     					JSR	SPC2	;Send 2 Spaces to terminal
000376r 1  A0 00        					LDY	#$00	;Initialize line byte counter
000378r 1  B1 C0        GETBYT		LDA	(INDEXL),Y	;Read indexed byte
00037Ar 1  20 rr rr     					JSR	PRBYTE	;Display byte as a HEX value
00037Dr 1  20 rr rr     					JSR	SPC	;Send Space to terminal
000380r 1  C8           					INY	;Increment index
000381r 1  C0 10        					CPY	#$10	;Check for all 16
000383r 1  D0 F3        					BNE	GETBYT	;loop back until 16 bytes have been displayed
000385r 1  20 rr rr     					JSR	SPC	;Send a space
000388r 1  B2 C0        GETBYT2		LDA	(INDEXL)	;Read indexed byte
00038Ar 1  20 rr rr     					JSR	PRASC	;Print ASCII character
00038Dr 1  20 rr rr     					JSR	INCINDEX	;Increment index
000390r 1  88           					DEY	;Decrement count (from 16)
000391r 1  D0 F5        					BNE	GETBYT2	;loop back until 16 bytes have been displayed
000393r 1  20 rr rr     					JSR	CROUT	;else, send CR,LF to terminal
000396r 1  A5 C0        					LDA	INDEXL	;Get current index low
000398r 1  85 C2        					STA	TEMP1L	;Save to temp1 low
00039Ar 1  A5 C1        					LDA	INDEXH	;Get current index high
00039Cr 1  85 C3        					STA	TEMP1H	;Save to temp1 high
00039Er 1  CA           					DEX	;Decrement line count
00039Fr 1  D0 CC        					BNE	DLINE	;Branch back until all 16 done
0003A1r 1  20 rr rr     					JSR	GLINE	;Send horizontal line to terminal
0003A4r 1               ;DMPGR subroutine: Send address offsets to terminal
0003A4r 1  A9 02        DMPGR			LDA	#$02	;Get msg for "addr:" to terminal
0003A6r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
0003A9r 1  20 rr rr     					JSR	SPC2	;Add two additional spaces
0003ACr 1  A2 00        					LDX	#$00	;Zero index count
0003AEr 1  8A           MDLOOP		TXA	;Send "00" thru "0F", separated by 1 Space, to terminal
0003AFr 1  20 rr rr     					JSR	PRBYTE	;Print byte value
0003B2r 1  20 rr rr     					JSR	SPC	;Add a space
0003B5r 1  E8           					INX	;Increment the count
0003B6r 1  E0 10        					CPX	#$10	;Check for 16
0003B8r 1  D0 F4        					BNE	MDLOOP	;Loop back until done
0003BAr 1               ;	Print the ASCII text header "0123456789ABCDEF"
0003BAr 1  20 rr rr     					JSR	SPC	;Send a space
0003BDr 1  A2 00        					LDX	#$00	;Zero X reg for "0"
0003BFr 1  8A           MTLOOP		TXA	;Xfer to A reg
0003C0r 1  20 rr rr     					JSR	BIN2ASC	;Convert Byte to two ASCII digits
0003C3r 1  98           					TYA	;Xfer the low nibble character to A reg
0003C4r 1  20 rr rr     					JSR	CHROUT	;Send least significant HEX to terminal
0003C7r 1  E8           					INX	;Increment to next HEX character
0003C8r 1  E0 10        					CPX	#$10	;Check for 16
0003CAr 1  D0 F3        					BNE	MTLOOP	;branch back till done
0003CCr 1  4C rr rr     					JMP	CROUT	;Do a CR/LF and return
0003CFr 1               ;
0003CFr 1               ;[E] Examine/Edit command: Display in HEX then change the contents of a specified memory address
0003CFr 1  20 rr rr     CHANGE		JSR	SETUP	;Request HEX address input from terminal
0003D2r 1  20 rr rr     CHNG_LP		JSR	SPC2	;Send 2 spaces
0003D5r 1  B2 C0        					LDA	(INDEXL)	;Read specified address
0003D7r 1  20 rr rr     					JSR	PRBYTE	;Display HEX value read
0003DAr 1  20 rr rr     					JSR	BSOUT3T ;Send 3 Backspaces
0003DDr 1  20 rr rr     					JSR	HEXIN2	;Get input, result in A reg
0003E0r 1  92 C0        					STA	(INDEXL)	;Save entered value at Index pointer
0003E2r 1  D2 C0        					CMP	(INDEXL)	;Compare to ensure a match
0003E4r 1  F0 05        					BEQ	CHOK	;Branch if compare is good
0003E6r 1  A9 3F        					LDA	#$3F	;Get "?" for bad compare
0003E8r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
0003EBr 1  20 rr rr     CHOK			JSR	INCINDEX	;Increment Index
0003EEr 1  80 E2        					BRA	CHNG_LP	;Loop to continue command
0003F0r 1               ;
0003F0r 1               ;[G] GO command: Begin executing program code at a specified address
0003F0r 1               ;Prompts the user for a start address, places it in COMLO/COMHI
0003F0r 1               ;If no address entered, uses default address at COMLO/COMHI
0003F0r 1               ;Loads the A,X,Y,P registers from presets and does a JSR to the routine
0003F0r 1               ;Upon return, registers are saved back to presets for display later
0003F0r 1               ;Also saves the stack pointer and status register upon return
0003F0r 1               ;Stack pointer is not changed due to constant IRQ service routines
0003F0r 1  F7 D5        GO				SMB7	CMDFLAG	;Set Command flag
0003F2r 1  20 rr rr     					JSR	SETUP	;Get HEX address (A/Y regs hold 16-bit value)
0003F5r 1  F0 04        					BEQ	EXEC_GO	;If not, setup registers and execute (Z flag set already)
0003F7r 1  85 BE        					STA	COMLO	;Save entered address to pointer low byte
0003F9r 1  84 BF        					STY	COMHI	;Save entered address to pointer hi byte
0003FBr 1               ;Preload all 65C02 MPU registers from monitor's preset/result variables
0003FBr 1  A5 E2        EXEC_GO		LDA	PREG	;Load processor status register preset
0003FDr 1  48           					PHA	;Push it to the stack
0003FEr 1  A5 E6        					LDA	AREG	;Load A-Reg preset
000400r 1  A6 E5        					LDX	XREG	;Load X-Reg preset
000402r 1  A4 E4        					LDY	YREG	;Load Y-Reg preset
000404r 1  28           					PLP	;Pull the processor status register
000405r 1               ;Call user program code as a subroutine
000405r 1  20 rr rr     					JSR	DOCOM	;Execute code at specified address
000408r 1               ;Store all 65C02 MPU registers to monitor's preset/result variables: store results
000408r 1  08           					PHP	;Save the processor status register to the stack
000409r 1  85 E6        					STA	AREG	;Store A-Reg result
00040Br 1  86 E5        					STX	XREG	;Store X-Reg result
00040Dr 1  84 E4        					STY	YREG	;Store Y-Reg result
00040Fr 1  68           					PLA	;Get the processor status register
000410r 1  85 E2        					STA	PREG	;Store the result
000412r 1  BA           					TSX	;Xfer stack pointer to X-reg
000413r 1  86 E3        					STX	SREG	;Store the result
000415r 1  D8           					CLD	;Clear BCD mode in case of sloppy user code ;-)
000416r 1  60           TXT_EXT		RTS	;Return to caller
000417r 1  6C BE 00     DOCOM			JMP	(COMLO)	;Execute the command
00041Ar 1               ;
00041Ar 1               ;[T] LOCATE TEXT STRING command: search memory for an entered text string
00041Ar 1               ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
00041Ar 1               ;SRCHTXT subroutine: request 1 - 16 character text string from terminal, followed by Return
00041Ar 1               ;[ESCAPE] aborts, [BACKSPACE] erases last keystroke. String will be stored in SRCHBUFF
00041Ar 1  A9 08        SRCHTXT		LDA	#$08	;Get msg " find text:"
00041Cr 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00041Fr 1  A2 00        					LDX	#$00	;Initialize index/byte counter
000421r 1  20 rr rr     STLOOP		JSR	CHRIN	;Get input from terminal
000424r 1  C9 0D        					CMP	#$0D	;Check for C/R
000426r 1  F0 3B        					BEQ	SRCHRDY	;Branch to search engine
000428r 1  C9 1B        					CMP	#$1B	;Check for ESC
00042Ar 1  F0 EA        					BEQ	TXT_EXT	;Exit to borrowed RTS
00042Cr 1  C9 08        					CMP	#$08	;Check for B/S
00042Er 1  D0 09        					BNE	STBRA	;If not, store character into buffer
000430r 1  8A           					TXA	;Xfer count to A reg
000431r 1  F0 EE        					BEQ	STLOOP	;Branch to input if zero
000433r 1  20 rr rr     					JSR	BSOUT	;Else, send B/S to terminal
000436r 1  CA           					DEX	;Decrement index/byte counter
000437r 1  80 E8        					BRA	STLOOP	;Branch back and continue
000439r 1  9D 40 03     STBRA			STA	SRCHBUFF,X	;Store character in buffer location
00043Cr 1  20 rr rr     					JSR	CHROUT	;Send character to terminal
00043Fr 1  E8           					INX	;Increment counter
000440r 1  E0 10        					CPX	#$10	;Check count for 16
000442r 1  D0 DD        					BNE	STLOOP	;Loop back for another character
000444r 1  80 1D        					BRA	SRCHRDY	;Branch to search engine
000446r 1               ;
000446r 1               ;[H] LOCATE BYTE STRING command: search memory for an entered byte string
000446r 1               ;Memory range scanned is $0800 through $FFFF (specified in SENGINE subroutine)
000446r 1               ;SRCHBYT subroutine: request 0 - 16 byte string from terminal, each byte followed by Return
000446r 1               ;[ESCAPE] aborts. HEX data will be stored in SRCHBUFF
000446r 1  F7 D5        SRCHBYT		SMB7	CMDFLAG	;Set Command flag
000448r 1  A9 09        					LDA	#$09	;Get msg " find bin:"
00044Ar 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00044Dr 1  A2 00        					LDX	#$00	;Initialize index
00044Fr 1  DA           SBLOOP		PHX	;Save index on stack
000450r 1  20 rr rr     					JSR	HEXIN2	;Request HEX byte
000453r 1  20 rr rr     					JSR	SPC	;Send space to terminal
000456r 1  FA           					PLX	;Restore index from stack
000457r 1  A4 CE        					LDY	BUFIDX	;Get # of characters entered
000459r 1  F0 08        					BEQ	SRCHRDY ;Branch if no characters
00045Br 1  9D 40 03     					STA	SRCHBUFF,X ;Else, store in buffer
00045Er 1  E8           					INX	;Increment index
00045Fr 1  E0 10        					CPX	#$10	;Check for 16 (max)
000461r 1  D0 EC        					BNE	SBLOOP	;Loop back until done/full
000463r 1  86 D0        SRCHRDY		STX	IDX	;Save input character count
000465r 1  E0 00        					CPX	#$00	;Check buffer count
000467r 1  F0 AD        					BEQ	TXT_EXT	;Exit if no bytes in buffer
000469r 1  A9 0C        					LDA	#$0C	;Else, get msg "Searching.."
00046Br 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00046Er 1               ;
00046Er 1               ;SENGINE subroutine: Scan memory range $0800 through $FFFF for exact match to string
00046Er 1               ;contained in buffer SRCHBUFF (1 to 16 bytes/characters). Display address of first
00046Er 1               ;byte/character of each match found until the end of memory is reached.
00046Er 1  A9 08        SENGINE		LDA	#$08	;Initialize address to $0800: skip over $0000 through $07FF
000470r 1  85 C1        					STA	INDEXH	;Store high byte
000472r 1  64 C0        					STZ	INDEXL ;Zero low byte
000474r 1  A2 00        SENGBR2		LDX	#$00	;Initialize buffer index
000476r 1  B2 C0        SENGBR3		LDA	(INDEXL)	;Read current memory location
000478r 1  DD 40 03     					CMP	SRCHBUFF,X	;Compare to search buffer
00047Br 1  F0 05        					BEQ	SENGBR1	;Branch for a match
00047Dr 1  20 rr rr     					JSR	SINCPTR	;Increment pointer, test for end of memory
000480r 1  80 F2        					BRA	SENGBR2	;Loop back to continue
000482r 1  20 rr rr     SENGBR1		JSR	SINCPTR	;Increment pointer, test for end of memory
000485r 1  E8           					INX	;Increment buffer index
000486r 1  E4 D0        					CPX	IDX	;Compare buffer index to address index
000488r 1  D0 EC        					BNE	SENGBR3	;Loop back until done
00048Ar 1  38           					SEC	;Subtract buffer index from memory pointer; Set carry
00048Br 1  A5 C0        					LDA	INDEXL	;Get current address for match lo byte
00048Dr 1  E5 D0        					SBC	IDX	;Subtract from buffer index
00048Fr 1  85 C0        					STA	INDEXL	;Save it back to lo address pointer
000491r 1  A5 C1        					LDA	INDEXH	;Get current address for match hi byte
000493r 1  E9 00        					SBC	#$00	;Subtract carry flag
000495r 1  85 C1        					STA	INDEXH	;Save it back to hi address pointer
000497r 1  A9 0B        					LDA	#$0B	;Get msg "found"
000499r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00049Cr 1  A9 3A        					LDA	#':'	;Get Ascii colon
00049Er 1  20 rr rr     					JSR	CHROUT	;Send to console
0004A1r 1  20 rr rr     					JSR	PRINDEX	;Print Index address
0004A4r 1  A9 0D        					LDA	#$0D	;Get msg "(n)ext? "
0004A6r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
0004A9r 1  20 rr rr     					JSR	RDCHAR	;Get input from terminal
0004ACr 1  C9 4E        					CMP	#$4E	;Check for "(n)ext"
0004AEr 1  D0 38        					BNE	NCAREG	;Exit if not requesting next
0004B0r 1  20 rr rr     					JSR	SINCPTR	;Increment address pointer, test for end of memory
0004B3r 1  80 BF        					BRA	SENGBR2	;Branch back and continue till done
0004B5r 1               ;
0004B5r 1               ;Increment memory address pointer. If pointer high byte = 00 (end of searchable ROM memory),
0004B5r 1               ;send "not found" to terminal then return to monitor
0004B5r 1  20 rr rr     SINCPTR		JSR	INCINDEX	;Increment Index pointer
0004B8r 1  A5 C1        					LDA	INDEXH	;Check for wrap to $0000
0004BAr 1  D0 2C        					BNE	NCAREG	;If not, return
0004BCr 1  68           					PLA	;Else, Pull return address from stack
0004BDr 1  68           					PLA	;and exit with msg
0004BEr 1  A9 0A        					LDA	#$0A	;Get msg "not found"
0004C0r 1  4C rr rr     					JMP	PROMPT	;Send msg to terminal and exit
0004C3r 1               ;
0004C3r 1               ;[P] Processor Status command: Display then change PS preset/result
0004C3r 1  A9 0E        PRG				LDA	#$0E	;Get MSG # for Processor Status register
0004C5r 1  80 0E        					BRA	REG_UPT	;Finish register update
0004C7r 1               ;
0004C7r 1               ;[S] Stack Pointer command: Display then change SP preset/result
0004C7r 1  A9 0F        SRG				LDA	#$0F	;Get MSG # for Stack register
0004C9r 1  80 0A        					BRA	REG_UPT	;Finish Register update
0004CBr 1               ;
0004CBr 1               ;[Y] Y-Register command: Display then change Y-reg preset/result
0004CBr 1  A9 10        YRG				LDA	#$10	;Get MSG # for Y Reg
0004CDr 1  80 06        					BRA	REG_UPT	;Finish register update
0004CFr 1               ;
0004CFr 1               ;[X] X-Register command: Display then change X-reg preset/result
0004CFr 1  A9 11        XRG				LDA	#$11	;Get MSG # for X Reg
0004D1r 1  80 02        					BRA	REG_UPT	;Finish register update
0004D3r 1               ;
0004D3r 1               ;[A] A-Register command: Display then change A-reg preset/result
0004D3r 1  A9 12        ARG				LDA	#$12	;Get MSG # for A reg
0004D5r 1               ;
0004D5r 1  48           REG_UPT		PHA	;Save MSG # to stack
0004D6r 1  AA           					TAX	;Xfer to X reg
0004D7r 1  20 rr rr     					JSR	PROMPT	;Print Register message
0004DAr 1  B5 D4        					LDA	PREG-$0E,X	;Read Register (A,X,Y,S,P) preset/result
0004DCr 1  20 rr rr     					JSR	PRBYTE	;Display HEX value of register
0004DFr 1  20 rr rr     					JSR	SPC	;Send [SPACE] to terminal
0004E2r 1  20 rr rr     					JSR	HEXIN2	;Get up to 2 HEX characters
0004E5r 1  FA           					PLX	;Get MSG # from stack
0004E6r 1  95 D4        					STA	PREG-$0E,X	;Write register (A,X,Y,S,P) preset/result
0004E8r 1  60           NCAREG		RTS	;Return to caller
0004E9r 1               ;
0004E9r 1               ;[R] REGISTERS command: Display contents of all preset/result memory locations
0004E9r 1  20 rr rr     PRSTAT		JSR	CHROUT	;Send "R" to terminal
0004ECr 1  A9 13        PRSTAT1		LDA	#$13	;Get Header msg
0004EEr 1  20 rr rr     					JSR	PROMPT	;Send to terminal
0004F1r 1  A5 E1        					LDA	PCH	;Get PC high byte
0004F3r 1  A4 E0        					LDY	PCL	;Get PC low byte
0004F5r 1  20 rr rr     					JSR	PRWORD	;Print 16-bit word
0004F8r 1  20 rr rr     					JSR	SPC	;Send 1 space
0004FBr 1               ;
0004FBr 1  A2 04        					LDX	#$04	;Set for count of 4
0004FDr 1  B5 E2        REGPLOOP	LDA	PREG,X	;Start with A reg variable
0004FFr 1  20 rr rr     					JSR	PRBYTE	;Print it
000502r 1  20 rr rr     					JSR	SPC	;Send 1 space
000505r 1  CA           					DEX	;Decrement count
000506r 1  D0 F5        					BNE	REGPLOOP	;Loop back till all 4 are sent
000508r 1               ;
000508r 1  A5 E2        					LDA	PREG	;Get Status register preset
00050Ar 1  A2 08        					LDX	#$08	;Get the index count for 8 bits
00050Cr 1  0A           SREG_LP		ASL	A	;Shift bit into Carry
00050Dr 1  48           					PHA	;Save current (shifted) SR value
00050Er 1  A9 30        					LDA	#$30	;Load an Ascii zero
000510r 1  69 00        					ADC	#$00	;Add zero (with Carry)
000512r 1  20 rr rr     					JSR	CHROUT	;Print bit value (0 or 1)
000515r 1  68           					PLA	;Get current (shifted) SR value
000516r 1  CA           					DEX	;Decrement bit count
000517r 1  D0 F3        					BNE	SREG_LP	;Loop back until all 8 printed
000519r 1  4C rr rr     					JMP	CROUT	;Send CR/LF and return
00051Cr 1               ;
00051Cr 1               ;[I] command: TEXT ENTRY enter ASCII text beginning at a specified address
00051Cr 1  20 rr rr     TEXT			JSR	SETUP	;Send "I" command, handle setup
00051Fr 1  20 rr rr     EDJMP1		JSR	CROUT	;Send CR,LF to terminal
000522r 1  85 C4        					STA	TEMP2L	;Save current edit address
000524r 1  84 C5        					STY	TEMP2H	;Save high byte
000526r 1  20 rr rr     EDJMP2		JSR	CHRIN	;Request a keystroke from terminal
000529r 1  C9 1B        					CMP	#$1B	;Check for end text entry
00052Br 1  F0 3C        					BEQ	EDITDUN	;Branch and close out if yes
00052Dr 1  C9 0D        					CMP	#$0D	;Else, check for Return key
00052Fr 1  D0 12        					BNE	ENOTRET	;Branch if not
000531r 1  92 C0        					STA	(INDEXL)	;Save CR to current Index pointer
000533r 1  20 rr rr     					JSR	INCINDEX	;Increment edit memory address pointer
000536r 1  A9 0A        					LDA	#$0A	;Get a LF character
000538r 1  92 C0        					STA	(INDEXL)	;Store it in memory
00053Ar 1  20 rr rr     					JSR	INCINDEX	;Increment edit memory address pointer
00053Dr 1  A5 C0        					LDA	INDEXL	;Get Start of next line
00053Fr 1  A4 C1        					LDY	INDEXH	;and the high byte
000541r 1  80 DC        					BRA	EDJMP1	;Loop back to continue
000543r 1  C9 08        ENOTRET		CMP	#$08	;Check for backspace character
000545r 1  F0 0A        					BEQ	EDBKSPC	;Branch if yes
000547r 1  92 C0        					STA	(INDEXL)	;Else, save to current Index pointer
000549r 1  20 rr rr     					JSR	CHROUT	;Send keystroke to terminal
00054Cr 1  20 rr rr     					JSR	INCINDEX	;Increment edit memory address pointer
00054Fr 1  80 D5        					BRA	EDJMP2	;Loop back to EDJMP2
000551r 1               ;Handle Backspace, don't allow past starting address
000551r 1  A5 C0        EDBKSPC		LDA	INDEXL	;Get current index low byte
000553r 1  C5 C4        					CMP	TEMP2L	;Compare to initial start address
000555r 1  D0 06        					BNE	EDDOBKS	;if not equal, perform backspace
000557r 1  A5 C1        					LDA	INDEXH	;Get current index high byte
000559r 1  C5 C5        					CMP	TEMP2H	;Compare to initial start address
00055Br 1  F0 C9        					BEQ	EDJMP2	;If same, branch to input loop
00055Dr 1  20 rr rr     EDDOBKS		JSR	BSOUT	;Send backspace to terminal
000560r 1  20 rr rr     					JSR	DECINDEX	;Decrement edit memory address pointer
000563r 1  A9 00        					LDA	#$00	;Get a null character
000565r 1  92 C0        					STA	(INDEXL)	;Store in place of character
000567r 1  80 BD        					BRA	EDJMP2	;LOOP back to EDJMP2
000569r 1  20 rr rr     EDITDUN		JSR	CR2	;Send 2 CR,LF to terminal
00056Cr 1  4C rr rr     					JMP	PRINDEX	;Print INDEX value
00056Fr 1               ;
00056Fr 1               ;[CTRL-B] Start Enhanced Basic:
00056Fr 1  A9 2F        EHBASIC		LDA	#$2F	;Get EhBasic intro Msg
000571r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000574r 1               ;
000574r 1  20 rr rr     EHB_TRY2	JSR	RDCHAR	;Get character (LC2UC)
000577r 1  C9 43        					CMP	#'C'	;Check for Cold start
000579r 1  F0 09        					BEQ	EHB_COLD	;If yes, go Cold Start
00057Br 1  C9 57        					CMP	#'W'	;Check for Warm start
00057Dr 1  F0 08        					BEQ	EHB_WARM	;If yes. go Warm start
00057Fr 1  20 rr rr     					JSR	BEEP	;Else, beep for entry error
000582r 1  80 F0        					BRA	EHB_TRY2	;Branch back and try again
000584r 1               ;
000584r 1  4C 00 B0     EHB_COLD	JMP	$B000	;Cold start ROM vector
000587r 1               ;
000587r 1  4C 00 00     EHB_WARM	JMP	$0000	;Warm start soft vector
00058Ar 1               ;
00058Ar 1               ;[CTRL-D]	Disassembler
00058Ar 1  A9 2B        DSSMBLR		LDA	#$2B	;Intro Message
00058Cr 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00058Fr 1  A9 03        					LDA	#$03	;Msg 03 -" addr:"
000591r 1  20 rr rr     					JSR	HEX4	;Print msg and get address
000594r 1  20 rr rr     					JSR	CROUT	;Send CR,LF to terminal
000597r 1  A2 16        RPT_LST		LDX	#$16	;Set list count to 22
000599r 1  DA           DIS_LOOP	PHX	;Push count to stack
00059Ar 1  20 rr rr     					JSR	DIS_LINE	;Disassemble 1 instruction
00059Dr 1  FA           					PLX	;Pull count from stack
00059Er 1  CA           					DEX	;Decrement count
00059Fr 1  D0 F8        					BNE	DIS_LOOP	;Loop back till list count is zero
0005A1r 1  20 rr rr     LST_LOOP	JSR	CHRIN	;Get input from terminal
0005A4r 1  C9 0D        					CMP	#$0D	;Check for Return key
0005A6r 1  F0 32        					BEQ	EXT_LIST	;Exit if Return
0005A8r 1  C9 20        					CMP	#$20	;Check for Space
0005AAr 1  D0 EB        					BNE	RPT_LST	;If not, go back and list another page
0005ACr 1  20 rr rr     					JSR	DIS_LINE	;Else, Disassemble one line
0005AFr 1  80 F0        					BRA	LST_LOOP	;Branch back and continue
0005B1r 1               ;
0005B1r 1               ;DISASSEMBLE LINE: disassemble 1 instruction from working address
0005B1r 1  20 rr rr     DIS_LINE	JSR	PRINDEX	;Print working address
0005B4r 1  20 rr rr     					JSR	SPC2	;Send 2 spaces to terminal
0005B7r 1  B2 C0        					LDA	(INDEXL)	;Read opcode from working memory pointer
0005B9r 1  85 D6        					STA	OPCODE	;Save opcode
0005BBr 1  20 rr rr     					JSR	PRB_SPC2	;Print byte, 2 spaces
0005BEr 1  4A           					LSR	A	;Divide by 2 / shift low order bit into carry flag
0005BFr 1  AA           					TAX	;Xfer Opcode /2 to X reg
0005C0r 1  BD rr rr     					LDA	HDLR_IDX,X	;Get Pointer to handler table
0005C3r 1  B0 04        					BCS	USE_RGHT	;If carry set use low nibble (odd)
0005C5r 1  4A           					LSR	A	;Else shift upper nibble to lower nibble (even)
0005C6r 1  4A           					LSR	A
0005C7r 1  4A           					LSR	A
0005C8r 1  4A           					LSR	A
0005C9r 1  29 0F        USE_RGHT	AND	#$0F	;Mask off high nibble
0005CBr 1  0A           					ASL	A	;Multiply by 2 for index
0005CCr 1  AA           					TAX	;Use handler pointer to index handler table
0005CDr 1  20 rr rr     					JSR	DODISL	;Call disassembler handler
0005D0r 1  20 rr rr     					JSR	CROUT	;Send CR,LF to terminal
0005D3r 1  64 D3        					STZ	TEMP2	;Clear all flag bits
0005D5r 1               ;
0005D5r 1               ;INCNDX routine: increment working address pointer then read it
0005D5r 1  20 rr rr     INCNDX		JSR	INCINDEX	;Increment working address pointer
0005D8r 1  B2 C0        					LDA	(INDEXL)	;Read from working memory address
0005DAr 1  60           EXT_LIST	RTS	;Done, return to caller/exit
0005DBr 1               ;
0005DBr 1  7C rr rr     DODISL		JMP	(HDLR_TAB,X)	;Execute address mode handler
0005DEr 1               ;
0005DEr 1               ;THREE BYTE routine: display operand bytes then mnemonic for three-byte instruction
0005DEr 1               ;TWO BYTE routine: display operand byte then mnemonic for two-byte instruction
0005DEr 1  F7 D3        TRI_BYTE	SMB7	TEMP2	;Set Flag bit for 3-byte instruction
0005E0r 1  20 rr rr     TWO_BYTE	JSR	GET_NEXT	;Read, display operand byte
0005E3r 1  85 D8        					STA	CRCLO	;Save operand byte in CRCLO
0005E5r 1  7F D3 0A     					BBR7	TEMP2,TWOBYTSPC	;Branch for 2-byte is clear
0005E8r 1  20 rr rr     					JSR	GET_NEXT	;Read, display operand high byte
0005EBr 1  85 D7        					STA	CRCHI	;Save operand high byte in CRCHI
0005EDr 1  80 06        					BRA	THREEBYTSPC	;Send 2 spaces, send Mnemonic, return
0005EFr 1               ;
0005EFr 1               ;IMPLIED disassembler handler: single byte instructions: implied mode
0005EFr 1               ;(note: ACC_MODE handler calls this)
0005EFr 1  20 rr rr     IMPLIED		JSR	SPC4	;Send 4 spaces
0005F2r 1  20 rr rr     TWOBYTSPC		JSR	SPC4	;Send 4 spaces
0005F5r 1  20 rr rr     THREEBYTSPC		JSR	SPC2	;Send 2 spaces
0005F8r 1               ;
0005F8r 1               ;PRT_MNEM subroutine: send 3 character mnemonic to terminal
0005F8r 1               ; Mnemonic indexed by opcode byte. Sends "???" if byte is not a valid opcode
0005F8r 1  A4 D6        PRT_MNEM	LDY	OPCODE	;Get current Opcode as index
0005FAr 1  BE rr rr     					LDX	MNE_PTAB,Y	;Get opcode pointer from table
0005FDr 1  BD rr rr     					LDA	DIS_NMEM,X	;Get left byte
000600r 1  85 DA        					STA	PTRL	;Store it to pointer
000602r 1  BD rr rr     					LDA	DIS_NMEM+1,X	;Get right byte
000605r 1  85 DB        					STA	PTRH	;Store it to pointer
000607r 1  A2 03        					LDX	#$03	;Set count for 3 characters
000609r 1  A9 00        NEXT_NME	LDA	#$00	;Zero A reg
00060Br 1  A0 05        					LDY	#$05	;Set count for 5 bits per character
00060Dr 1  06 DB        LOOP_NME	ASL	PTRH	;Shift right byte into carry
00060Fr 1  26 DA        					ROL	PTRL	;Rotate left byte byte into A reg
000611r 1  2A           					ROL	A	;Rotate into A reg
000612r 1  88           					DEY	;Decrement bit count
000613r 1  D0 F8        					BNE	LOOP_NME	;Loop back till 5 bits in A reg
000615r 1  69 3F        					ADC	#$3F	;Add $3F to convert to Ascii
000617r 1  20 rr rr     					JSR	CHROUT	;Send the character to terminal
00061Ar 1  CA           					DEX	;Decrement character count
00061Br 1  D0 EC        					BNE	NEXT_NME	;Loop back till 3 characters sent
00061Dr 1  80 06        					BRA	BR_SPC2	;Send 2 spaces to terminal, return
00061Fr 1               ;
00061Fr 1               ;GET_NEXT subroutine: increment/read working address
00061Fr 1               ; Display byte, send 2 spaces to terminal (displays operand byte(s))
00061Fr 1  20 rr rr     GET_NEXT	JSR	INCNDX	;Increment working index
000622r 1  20 rr rr     PRB_SPC2	JSR	PRBYTE	;Display Byte from working index
000625r 1  4C rr rr     BR_SPC2		JMP	SPC2	;Send 2 spaces to terminal and return
000628r 1               ;
000628r 1               ;Disassembler handlers:
000628r 1               ;
000628r 1               ;LF_BRKT subroutine: send "(" to terminal
000628r 1  A9 28        LF_BRKT		LDA	#$28	;Get "("
00062Ar 1  80 0F        					BRA	BR_COUT	;Send to terminal and return
00062Cr 1               ;
00062Cr 1               ;ZP_IMMEDIATE: two byte instructions: zero-page immediate mode
00062Cr 1  20 rr rr     ZP_IMED		JSR	TWO_BYTE	;Display operand byte, then mnemonic
00062Fr 1  A9 23        					LDA	#$23	;Get "#" character
000631r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
000634r 1  80 1B        					BRA	PRT1_OP	;Display operand byte again, return
000636r 1               ;
000636r 1               ;ACC_MODE: single byte A reg mode instructions: implied mode
000636r 1  20 rr rr     ACC_MODE	JSR	IMPLIED	;Send 10 spaces to terminal then display mnemonic
000639r 1  A9 41        					LDA	#$41	;Get "A" character
00063Br 1  4C rr rr     BR_COUT		JMP	CHROUT	;Send it and return
00063Er 1               ;
00063Er 1               ;ABSOLUTE: three byte instructions: absolute mode
00063Er 1  20 rr rr     ABSOLUTE	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
000641r 1               ;
000641r 1               ;Print 2 Operands: display operand bytes of a three-byte instruction
000641r 1  20 rr rr     PRT2_OP		JSR	DOLLAR	;Send "$" to terminal
000644r 1  A5 D7        					LDA	CRCHI	;Load operand high byte
000646r 1  20 rr rr     					JSR	PRBYTE	;Send to terminal
000649r 1  A5 D8        BR_PRBTE	LDA	CRCLO	;Load operand low byte
00064Br 1  4C rr rr     					JMP	PRBYTE	;Send to terminal and return
00064Er 1               ;
00064Er 1               ;ZP_ABS: two byte instructions: zero-page absolute
00064Er 1  20 rr rr     ZP_ABS		JSR	TWO_BYTE	;Display operand byte, then mnemonic
000651r 1               ;
000651r 1               ;Print 1 Operand byte: display operand byte of a two-byte instruction
000651r 1  20 rr rr     PRT1_OP		JSR	DOLLAR	;Send "$" to terminal
000654r 1  80 F3        					BRA	BR_PRBTE	;Branch to complete
000656r 1               ;
000656r 1               ;INDIRECT: two or three byte instructions: indirect modes
000656r 1  A5 D6        INDIRECT	LDA	OPCODE	;Read saved opcode byte
000658r 1  C9 6C        					CMP	#$6C	;Check for JMP(INDIRECT)
00065Ar 1  D0 13        					BNE	ZP_IND	;Branch if not
00065Cr 1               ;
00065Cr 1  20 rr rr     					JSR	TRI_BYTE	;Display operand bytes, then mnemonic
00065Fr 1  20 rr rr     					JSR	LF_BRKT	;Send "(" to terminal
000662r 1  20 rr rr     					JSR	PRT2_OP	;Display operand bytes again
000665r 1  80 0B        					BRA	RT_BRKT	;Send ")" to terminal, return
000667r 1               ;
000667r 1               ;Following group is used multiple times, space savings
000667r 1  20 rr rr     DSPLY3		JSR	TWO_BYTE	;Display operand byte, then mnemonic
00066Ar 1  20 rr rr     					JSR	LF_BRKT	;Send "(" to terminal
00066Dr 1  80 E2        					BRA	PRT1_OP	;Display operand byte again, return
00066Fr 1               ;
00066Fr 1               ;this is for a two byte instruction: zero page indirect mode
00066Fr 1  20 rr rr     ZP_IND		JSR	DSPLY3	;Do the 3 routines
000672r 1               ;
000672r 1               ;RT_BRKT subroutine: send ")" to terminal
000672r 1  A9 29        RT_BRKT		LDA	#$29	;Get ")"
000674r 1  80 C5        					BRA	BR_COUT	;Send to terminal and return
000676r 1               ;
000676r 1               ;ZP_ABS_X: two byte instructions: zero-page absolute indexed by X mode
000676r 1  20 rr rr     ZP_ABS_X	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
000679r 1               ;
000679r 1               ;Print Comma,X: send ",X" to terminal
000679r 1  A9 2C        COM_X			LDA	#$2C	;Get ","
00067Br 1  20 rr rr     					JSR	CHROUT	;Send to terminal
00067Er 1  A9 58        					LDA	#$58	;Get "X"
000680r 1  80 B9        					BRA	BR_COUT	;Send to terminal, return
000682r 1               ;
000682r 1               ;ZP_ABS_Y: two byte instructions: zero-page absolute indexed by Y mode
000682r 1  20 rr rr     ZP_ABS_Y	JSR	ZP_ABS	;Display operand byte, mnemonic, operand byte
000685r 1               ;
000685r 1               ;Print Comma,Y: send ",Y" to terminal
000685r 1  A9 2C        COM_Y			LDA	#$2C	;Get ","
000687r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
00068Ar 1  A9 59        					LDA	#$59	;Get "Y"
00068Cr 1  80 AD        					BRA	BR_COUT	;Send to terminal, return
00068Er 1               ;
00068Er 1               ;ABS_Y: three byte instructions: absolute indexed by Y mode
00068Er 1               ;ABS_X: three byte instructions: absolute indexed by X mode
00068Er 1  E7 D3        ABS_Y			SMB6	TEMP2
000690r 1  20 rr rr     ABS_X			JSR	TRI_BYTE	;Display operand bytes, then mnemonic
000693r 1  20 rr rr     					JSR	PRT2_OP	;Display operand bytes again
000696r 1  EF D3 EC     					BBS6	TEMP2,COM_Y
000699r 1  80 DE        					BRA	COM_X	;Send ",X" to terminal, return
00069Br 1               ;
00069Br 1               ;ZP_IND_X: two byte instructions: zero-page indirect pre-indexed by X mode
00069Br 1  20 rr rr     ZP_IND_X	JSR	DSPLY3	;Do the 3 routines
00069Er 1  20 rr rr     					JSR	COM_X	;Send ",X" to terminal
0006A1r 1  80 CF        					BRA	RT_BRKT	;Send ")" to terminal, return
0006A3r 1               ;
0006A3r 1               ;ZP_IND_Y: two byte instructions: zero-page indirect post-indexed by Y mode
0006A3r 1  20 rr rr     ZP_IND_Y	JSR	DSPLY3	;Do the 3 routines
0006A6r 1  20 rr rr     					JSR	RT_BRKT	;Send ")" to terminal
0006A9r 1  80 DA        					BRA	COM_Y	;Send ",Y" to terminal, return
0006ABr 1               ;
0006ABr 1               ;IND_ABS_X: three byte instruction: JMP (INDIRECT,X) 16 bit indirect
0006ABr 1  20 rr rr     IND_ABS_X	JSR	TRI_BYTE	;Display operand bytes, then mnemonic
0006AEr 1  20 rr rr     					JSR	LF_BRKT	;Send "(" to terminal
0006B1r 1  20 rr rr     					JSR	PRT2_OP	;Display operand bytes again
0006B4r 1  20 rr rr     					JSR	COM_X	;Send ",X" to terminal
0006B7r 1  80 B9        					BRA	RT_BRKT	;Send ")" to terminal then done INDABSX handler, RETURN
0006B9r 1               ;
0006B9r 1               ;ZP_XMB: two byte instructions: zero page set/clear memory bit
0006B9r 1  20 rr rr     ZP_XMB		JSR	SRMB	;Display operand byte, mnemonic, isolate bit selector from opcode
0006BCr 1  C9 08        					CMP	#$08	;Check if 0-7 or 8-F
0006BEr 1  90 02        					BCC	SRBIT	;Just add $30 (0-7)
0006C0r 1  E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
0006C2r 1  18           SRBIT			CLC	;Convert bit selector value to an ASCII decimal digit
0006C3r 1  69 30        					ADC	#$30	;add "0" to bit selector value
0006C5r 1  20 rr rr     					JSR	CHROUT	;Send digit to terminal
0006C8r 1  20 rr rr     					JSR	SPC	;Send a space to terminal
0006CBr 1  80 84        					BRA	PRT1_OP	;Display operand byte again then return
0006CDr 1               ;
0006CDr 1               ;ZP_BBX: three byte instruction: branch on zero-page bit set/clear
0006CDr 1  20 rr rr     ZP_BBX		JSR	SRMB2	;Display operand bytes, mnemonic, isolate bit selector from opcode
0006D0r 1  C9 08        					CMP	#$08	;Check if $0-$7 or $8-$F
0006D2r 1  90 02        					BCC	SRBIT2	;Just add $30 ($0-$7)
0006D4r 1  E9 08        					SBC	#$08	;Subtract $08 - convert $8-$F to $0-$7
0006D6r 1  20 rr rr     SRBIT2		JSR	SRBIT	;Convert and display bit selector digit
0006D9r 1  A5 D7        					LDA	CRCHI	;Move second operand to first operand position:
0006DBr 1  85 D8        					STA	CRCLO	;CRCLO = branch offset
0006DDr 1  20 rr rr     					JSR	SPC	;Send a space to terminal
0006E0r 1  80 03        					BRA	BBX_REL	;Display branch target address then return
0006E2r 1               ;
0006E2r 1               ;RELATIVE BRANCH: two byte relative branch mode
0006E2r 1               ;BBX_REL: three byte relative branch mode
0006E2r 1               ;both calculate then display relative branch target address
0006E2r 1  20 rr rr     REL_BRA		JSR	TWO_BYTE	;Display operand byte, then mnemonic
0006E5r 1  20 rr rr     BBX_REL		JSR	DOLLAR	;Send "$" to terminal
0006E8r 1  20 rr rr     					JSR	INCINDEX	;Increment working address, ref for branch offset
0006EBr 1  A5 D8        					LDA	CRCLO	;Get branch operand value
0006EDr 1  30 0A        					BMI	BRA_MINUS	;Check for $80 or higher (if branch is + or -)
0006EFr 1  18           					CLC	;Clear carry for add
0006F0r 1  65 C0        					ADC	INDEXL	;Add to Index lo
0006F2r 1  A8           					TAY	;Xfer to Y reg
0006F3r 1  A5 C1        					LDA	INDEXH	;Get Index Hi
0006F5r 1  69 00        					ADC	#$00	;Add result from Carry flag to A reg
0006F7r 1  80 0F        					BRA	REL_EXT	;Print offset, cleanup, return
0006F9r 1  49 FF        BRA_MINUS	EOR	#$FF	;Get 1's complement of offset
0006FBr 1  1A           					INC	A	;Increment by 1
0006FCr 1  85 D4        					STA  TEMP3	;Save result
0006FEr 1  38           					SEC	;Set carry for subtract
0006FFr 1  A5 C0        					LDA	INDEXL	;Get address low
000701r 1  E5 D4        					SBC	TEMP3	;Subtract branch offset
000703r 1  A8           					TAY	;Xfer to Y reg
000704r 1  A5 C1        					LDA	INDEXH	;Get address high
000706r 1  E9 00        					SBC	#$00	;Subtract carry flag
000708r 1  20 rr rr     REL_EXT		JSR	PRWORD	;Send address to terminal
00070Br 1  4C rr rr     					JMP	DECINDEX	;Decrement working address, return
00070Er 1               ;
00070Er 1               ;SRMB2 subroutine: display 2 operand bytes, mnemonic, isolate bit selector from opcode
00070Er 1               ;SRMB subroutine: display 1 operand byte, mnemonic, isolate bit selector from opcode
00070Er 1  B2 C0        SRMB2			LDA	(INDEXL)	;Read from working index
000710r 1  48           					PHA	;Save byte to stack
000711r 1  20 rr rr     					JSR	TRI_BYTE	;Display operand bytes and mnemonic
000714r 1  80 06        					BRA	SRM	;Skip down
000716r 1  B2 C0        SRMB			LDA	(INDEXL)	;Read from working index
000718r 1  48           					PHA	;Save byte on STACK
000719r 1  20 rr rr     					JSR	TWO_BYTE	;Display operand byte and mnemonic
00071Cr 1  20 rr rr     SRM				JSR	BSOUT2T	;Send 2 Backspaces
00071Fr 1  68           					PLA	;Restore byte from stack
000720r 1  4A           					LSR	A	;Shift high nibble to low nibble
000721r 1  4A           					LSR	A
000722r 1  4A           					LSR	A
000723r 1  4A           					LSR	A
000724r 1  60           NOCHAR		RTS	;Done SRMB2/SRMB, return
000725r 1               ;
000725r 1               ;END OF DISASSEMBLER CODE
000725r 1               ;
000725r 1               ;[CNTRL-V] Version command:
000725r 1  A9 15        VER				LDA	#$15	;Get Intro substring (version)
000727r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
00072Ar 1  A0 rr        					LDY	#>BIOS_MSG	;Get high offset
00072Cr 1  A9 rr        					LDA	#<BIOS_MSG	;Get low offset
00072Er 1  84 C7        PROMPTR		STY	PROMPTH	;Store hi byte
000730r 1  85 C6        					STA	PROMPTL	;Store lo byte
000732r 1  80 0E        					BRA	PROMPT2	;Print message
000734r 1               ;
000734r 1               ;[CNTRL-Q] Query command:
000734r 1  A9 2C        QUERY			LDA	#$2C	;Get Query msg #
000736r 1               ;
000736r 1               ;PROMPT routine: Send indexed text string to terminal. Index is A reg
000736r 1               ;string buffer address is stored in variable PROMPTL, PROMPTH
000736r 1               ;Routine is placed here in the Commands area to save ROM space
000736r 1  0A           PROMPT		ASL	A	;Multiply by two for msg table index
000737r 1  A8           					TAY	;Xfer to index
000738r 1  B9 rr rr     					LDA	MSG_TABLE,Y	;Get low byte address
00073Br 1  85 C6        					STA	PROMPTL	;Store in Buffer pointer
00073Dr 1  B9 rr rr     					LDA	MSG_TABLE+1,Y	;Get high byte address
000740r 1  85 C7        					STA	PROMPTH	;Store in Buffer pointer
000742r 1               ;
000742r 1  B2 C6        PROMPT2		LDA	(PROMPTL)	;Get string data
000744r 1  F0 DE        					BEQ	NOCHAR	;If null character, exit (borrowed RTS)
000746r 1  20 rr rr     					JSR	CHROUT	;Send character to terminal
000749r 1  E6 C6        					INC	PROMPTL	;Increment low byte index
00074Br 1  D0 F5        					BNE	PROMPT2	;Loop back for next character
00074Dr 1  E6 C7        					INC	PROMPTH	;Increment high byte index
00074Fr 1  80 F1        					BRA	PROMPT2	;Loop back and continue printing
000751r 1               ;
000751r 1               ;[CNTL-T] UPTIME command: Sends a string to the terminal showing the uptime
000751r 1               ; of the system since the last system reset. This routine uses the RTC values
000751r 1               ; for Days, Hours, Minutes and seconds. It converts each to BCD and outputs
000751r 1               ; to the terminal with text fields. The routine does not calculate months/years
000751r 1               ;
000751r 1  A9 1A        UPTIME		LDA	#$1A	;Get Uptime message
000753r 1  20 rr rr     					JSR	PROMPT	;Send to terminal
000756r 1               ;
000756r 1  A2 1B        					LDX	#$1B	;Get Days message
000758r 1  A5 F2        					LDA	DAYSL	;Get Days low byte
00075Ar 1  A4 F3        					LDY	DAYSH	;Get Days high byte
00075Cr 1  20 rr rr     					JSR	DO16TIME	;Convert and send to terminal
00075Fr 1               ;
00075Fr 1  A2 1C        					LDX	#$1C	;Get Hours message
000761r 1  A5 F1        					LDA	HOURS	;Get Current Hours (low byte)
000763r 1  20 rr rr     					JSR	DO8TIME	;Convert and send to terminal
000766r 1               ;
000766r 1  A2 1D        					LDX	#$1D	;Get Minutes message
000768r 1  A5 F0        					LDA	MINS	;Get Current Minutes (low byte)
00076Ar 1  20 rr rr     					JSR	DO8TIME	;Convert and send to terminal
00076Dr 1               ;
00076Dr 1  A2 1E        					LDX	#$1E	;Get seconds message
00076Fr 1  A5 EF        					LDA	SECS	;Get Current Seconds (low byte)
000771r 1               ;
000771r 1  A0 00        DO8TIME		LDY	#$00	;Zero high byte
000773r 1  DA           DO16TIME	PHX	;Push message number to stack
000774r 1  20 rr rr     					JSR	HEX2ASC	;Convert and print ASCII string
000777r 1  68           					PLA	;Pull message number from stack
000778r 1  80 BC        					BRA	PROMPT	;Branch to Prompt
00077Ar 1               ;
00077Ar 1               ;[CNTRL-L] Xmodem/CRC Loader command: receives a file from console via Xmodem protocol
00077Ar 1               ; no cable swapping needed, uses existing console port and buffer via the terminal program
00077Ar 1               ; not a full blown Xmodem/CRC implementation, only does CRC-16 checking, no fallback
00077Ar 1               ; designed specifically for direct attach to host machine via com port
00077Ar 1               ; can handle full 8-bit binary transfers without error
00077Ar 1               ; tested with ExtraPutty and TeraTerm (Note: TeraTerm doesn't respond to CAN properly)
00077Ar 1               ;
00077Ar 1               ; Added support for Motorola S-Record formatted files automatically
00077Ar 1               ; A parameter input is used as either a Load address for any non-S-record file
00077Ar 1               ; If the received file has a valid S-Record format, the parameter is used as a
00077Ar 1               ; positive address Offset applied to the specified load address in the S-record file
00077Ar 1               ; supported format is S19 as created by the WDC Tools linker.
00077Ar 1               ; Note: this code supports the execution address in the final S9 record, but WDC Tools
00077Ar 1               ; does not provide any ability to put this into their code build. WDC are aware of this
00077Ar 1               ;
00077Ar 1  F7 D5        XMODEM		SMB7	CMDFLAG	;Set Command flag
00077Cr 1  64 FE        					STZ	XMFLAG	;Clear Xmodem flag
00077Er 1  A9 01        					LDA	#$01	;Set block count to one
000780r 1  85 DC        					STA	BLKNO	;Save it for starting block #
000782r 1  A9 27        					LDA	#$27	;Get Xmodem intro msg
000784r 1  20 rr rr     					JSR	HEX4	;Print Msg, get Hex load address/S-record Offset
000787r 1  20 rr rr     					JSR	CROUT	;Send a C/R to show input entered
00078Ar 1  E0 00        					CPX	#$00	;Check for input entered (if non-zero, use new data)
00078Cr 1  D0 03        					BNE	XLINE	;Branch if data entered
00078Er 1  8A           					TXA	;Xfer to A reg (LDA #$00)
00078Fr 1  A0 08        					LDY	#$08	;Set High byte ($0800)
000791r 1  85 DA        XLINE			STA	PTRL	;Store to Lo pointer
000793r 1  84 DB        					STY	PTRH	;Store to Hi pointer
000795r 1               ;Wait for 5 seconds for user to setup xfer from terminal
000795r 1  A9 02        					LDA	#$02	;Load milliseconds = 2 ms
000797r 1  A2 0A        					LDX	#$0A	;Load High multipler to 10 decimal
000799r 1  A0 FA        					LDY	#$FA	;Load Low multipler to 250 decimal
00079Br 1  20 rr rr     					JSR	SET_DLY	;Set Delay parameters
00079Er 1  20 rr rr     					JSR	EXE_LGDLY	;Call long delay for 5 seconds
0007A1r 1               ;
0007A1r 1  A9 43        STRT_XFER	LDA	#'C'	;Send "C" character for CRC mode
0007A3r 1  20 rr rr     					JSR	CHROUT	;Send to terminal
0007A6r 1  20 rr rr     CHR_DLY		JSR	EXE_MSDLY	;Delay 2 milliseconds
0007A9r 1  A5 E7        					LDA	ICNT	;Check input buffer count
0007ABr 1  D0 38        					BNE	STRT_BLK	;If a character is in, branch
0007ADr 1  88           					DEY	;Decrement loop count (250 1st time only)
0007AEr 1  D0 F6        					BNE	CHR_DLY	;Branch and check again 250/256 times
0007B0r 1  80 EF        					BRA	STRT_XFER	;Else, branch and send another "C"
0007B2r 1               ;
0007B2r 1  A9 06        XDONE			LDA	#ACK	;Last block, get ACK character
0007B4r 1  20 rr rr     					JSR	CHROUT	;Send final ACK
0007B7r 1  A0 02        					LDY	#$02	;Get delay count
0007B9r 1  A9 28        					LDA	#$28	;Get Good xfer message number
0007BBr 1  20 rr rr     FLSH_DLY	JSR NOLOOPS	;Zero input buffer pointers
0007BEr 1  48           					PHA	;Save Message number
0007BFr 1  A9 FA        					LDA	#$FA	;Load milliseconds = 250 ms
0007C1r 1  A2 00        					LDX	#$00	;Load High multipler to 0 decimal
0007C3r 1  20 rr rr     					JSR	SET_DLY	;Set Delay parameters
0007C6r 1  20 rr rr     					JSR	EXE_LGDLY	;Execute delay, (wait to get terminal back)
0007C9r 1  68           					PLA	;Get message number back
0007CAr 1  C9 29        					CMP	#$29	;Check for error msg#
0007CCr 1  F0 14        					BEQ	SHRT_EXIT	;Do only one message
0007CEr 1  48           					PHA	;Save MSG number
0007CFr 1  7F FE 0F     					BBR7	XMFLAG,END_LOAD	;Branch if no S-record
0007D2r 1  A9 2A        					LDA	#$2A	;Get S-Record load address msg
0007D4r 1  20 rr rr     					JSR	PROMPT	;Printer header msg
0007D7r 1  A5 C9        					LDA	SRCH	;Get source high byte
0007D9r 1  A4 C8        					LDY	SRCL	;Get source low byte
0007DBr 1  20 rr rr     					JSR	PRWORD	;Print Hex address
0007DEr 1  20 rr rr     					JSR	CROUT	;Print C/R and return
0007E1r 1  68           END_LOAD	PLA	;Get Message number
0007E2r 1  4C rr rr     SHRT_EXIT	JMP	PROMPT	;Print Message and exit
0007E5r 1               ;
0007E5r 1  20 rr rr     STRT_BLK	JSR	CHRIN	;Get a character
0007E8r 1  C9 1B        					CMP	#$1B	;Is it escape - quit?
0007EAr 1  F0 0A        					BEQ	XM_END	;If yes, exit
0007ECr 1  C9 01        					CMP	#SOH	;Start of header?
0007EEr 1  F0 07        					BEQ	GET_BLK	;If yes, branch and receive block
0007F0r 1  C9 04        					CMP	#EOT	;End of Transmission?
0007F2r 1  F0 BE        					BEQ	XDONE	;If yes, branch and exit
0007F4r 1  80 63        					BRA	STRT_ERR	;Else branch to error
0007F6r 1  60           XM_END		RTS	;Cancelled by user, return
0007F7r 1               ;
0007F7r 1  E7 FE        GET_BLK		SMB6	XMFLAG	;Set bit 6 for Xmodem xfer
0007F9r 1  A2 00        					LDX	#$00	;Zero index for block receive
0007FBr 1               ;
0007FBr 1  20 rr rr     GET_BLK1	JSR	CHRIN	;Get a character
0007FEr 1  9D 7C 03     					STA	RBUFF,X	;Move into buffer
000801r 1  E8           					INX	;Increment buffer index
000802r 1  E0 84        					CPX	#$84	;Compare size (<01><FE><128 bytes><CRCH><CRCL>)
000804r 1  D0 F5        					BNE	GET_BLK1	;If not done, loop back and continue
000806r 1  67 FE        					RMB6	XMFLAG	;Reset Xmodem xfer bit (allows break)
000808r 1               ;
000808r 1  AD 7C 03     					LDA	RBUFF	;Get block number from buffer
00080Br 1  C5 DC        					CMP	BLKNO	;Compare to expected block number
00080Dr 1  D0 07        					BNE	RESTRT	;If not correct, restart the block
00080Fr 1  49 FF        					EOR	#$FF	;one's complement of block number
000811r 1  CD 7D 03     					CMP	RBUFF+1	;Compare with expected one's complement of block number
000814r 1  F0 07        					BEQ	BLK_OKAY	;Branch if compare is good
000816r 1               ;
000816r 1  A9 15        RESTRT		LDA	#NAK	;Get NAK character
000818r 1  20 rr rr     RESTRT2		JSR	CHROUT	;Send to xfer program
00081Br 1  80 C8        					BRA	STRT_BLK	;Restart block transfer
00081Dr 1               ;
00081Dr 1  A9 0A        BLK_OKAY	LDA	#$0A	;Set retry value to 10
00081Fr 1  85 D9        					STA	CRCCNT	;Save it to CRC retry count
000821r 1  64 D8        					STZ	CRCLO	;Reset the CRC value by (3)
000823r 1  64 D7        					STZ	CRCHI	;putting all bits off (3)
000825r 1  A0 00        					LDY #$00	;Set index for data offset (2)
000827r 1  B9 7E 03     CALCCRC		LDA	RBUFF+2,Y	;Get first data byte (4)
00082Ar 1  08           					PHP	;Save status reg (3)
00082Br 1  A2 08        					LDX	#$08	;Load index for 8 bits (2)
00082Dr 1  45 D7        					EOR	CRCHI	;XOR High CRC byte
00082Fr 1  06 D8        CRCLOOP		ASL	CRCLO	;Shift carry to CRC low byte (4)
000831r 1  2A           					ROL	A	;Shift bit to carry flag (2)
000832r 1  90 0A        					BCC	CRCLP1	;Branch if MSB is 1 (2/3)
000834r 1  49 10        					EOR	#$10	;Exclusive OR with polynomial (2)
000836r 1  48           					PHA	;Save result on stack (3)
000837r 1  A5 D8        					LDA	CRCLO	;Get CRC low byte (3)
000839r 1  49 21        					EOR	#$21	;Exclusive OR with polynomial (2)
00083Br 1  85 D8        					STA	CRCLO	;Save it back (3)
00083Dr 1  68           					PLA	;Get previous result (4)
00083Er 1  CA           CRCLP1		DEX	;Decrement index (2)
00083Fr 1  D0 EE        					BNE	CRCLOOP	;Loop back for all 8 bits (2/3)
000841r 1  85 D7        					STA	CRCHI	;Update CRC high byte (3)
000843r 1  28           					PLP ;Restore status reg (4)
000844r 1  C8           					INY	;Increment index to the next data byte (2)
000845r 1  10 E0        					BPL	CALCCRC	;Branch back until all 128 fed to CRC routine (2/3)
000847r 1  B9 7E 03     					LDA	RBUFF+2,Y	;Get received CRC hi byte (4)
00084Ar 1  C5 D7        					CMP	CRCHI	;Compare against calculated CRC hi byte (3)
00084Cr 1  D0 07        					BNE	BADCRC	;If bad CRC, handle error (2/3)
00084Er 1  B9 7F 03     					LDA	RBUFF+3,Y	;Get CRC lo byte (4)
000851r 1  C5 D8        					CMP	CRCLO	;Compare against calculated CRC lo byte (3)
000853r 1  F0 15        					BEQ	GOODCRC	;If good, go move frame to memory (2/3)
000855r 1               ;
000855r 1               ;CRC was bad... need to retry and receive the last frame again
000855r 1               ;Decrement the CRC retry count, send a NAK and try again
000855r 1               ;Count allows up to 10 retries, then cancels the transfer
000855r 1               ;
000855r 1  C6 D9        BADCRC		DEC	CRCCNT	;Decrement retry count
000857r 1  D0 0C        					BNE	CRCRTRY	;Retry again if count not zero
000859r 1  A9 18        STRT_ERR	LDA	#CAN	;Else get Cancel code
00085Br 1  20 rr rr     					JSR	CHROUT	;Send it to terminal program
00085Er 1  A0 08        					LDY	#$08	;Set delay multiplier
000860r 1  A9 29        					LDA	#$29	;Get message for receive error
000862r 1  4C rr rr     					JMP	FLSH_DLY	;Do a flush, delay and exit
000865r 1  20 rr rr     CRCRTRY		JSR	NOLOOPS	;Zero Input buffer pointers
000868r 1  80 AC        					BRA	RESTRT	;Send NAK and retry
00086Ar 1               ;
00086Ar 1               ;Block has been received, check for S19 record transfer
00086Ar 1  FF FE 2D     GOODCRC		BBS7	XMFLAG,XFER_S19	;Branch if bit 7 set (active S-record)
00086Dr 1  A5 DC        					LDA	BLKNO	;Else, check current block number
00086Fr 1  3A           					DEC	A	;Check for block 1 only (first time thru)
000870r 1  F0 16        					BEQ	TEST_S19	;If yes, test for S19 record
000872r 1               ;
000872r 1  A2 00        MOVE_BLK	LDX	#$00	;Zero index offset to data
000874r 1  BD 7E 03     COPYBLK		LDA	RBUFF+2,X	;Get data byte from buffer
000877r 1  92 DA        					STA	(PTRL)	;Store to target address
000879r 1  E6 DA        					INC	PTRL	;Incrememnt low address byte
00087Br 1  D0 02        					BNE	COPYBLK2	;Check for hi byte loop
00087Dr 1  E6 DB        					INC	PTRH	;Increment hi byte address
00087Fr 1  E8           COPYBLK2	INX	;Point to next data byte
000880r 1  10 F2        					BPL	COPYBLK	;Loop back until done (128)
000882r 1  E6 DC        INCBLK		INC	BLKNO	;Increment block number
000884r 1  A9 06        					LDA	#ACK	;Get ACK character
000886r 1  80 90        					BRA	RESTRT2	;Send ACK and continue xfer
000888r 1               ;
000888r 1  AD 7E 03     TEST_S19	LDA	RBUFF+2	;Get first character
00088Br 1  C9 53        					CMP	#'S'	;Check for S character
00088Dr 1  D0 E3        					BNE	MOVE_BLK	;If not equal, no S-record, move block
00088Fr 1  AD 7F 03     					LDA	RBUFF+3	;Get second character
000892r 1  C9 31        					CMP	#'1'	;Check for 1 character
000894r 1  D0 DC        					BNE	MOVE_BLK	;If not equal, no S-record, move block
000896r 1  F7 FE        					SMB7	XMFLAG	;Set bit 7 for S-record xfer
000898r 1  64 D1        					STZ	IDY	;Zero index for SRBUFF
00089Ar 1               ;
00089Ar 1               ; S-record transfer routine
00089Ar 1               ;	Xmodem is a 128 byte data block, S-record is variable, up to 44 byte block
00089Ar 1               ;	need to move a record at a time to the SRBUFF based on length, check as valid,
00089Ar 1               ;	then calculate address and transfer to that location
00089Ar 1               ;	once the Xmodem buffer is empty, loop back to get the next frame
00089Ar 1               ;	and continue processing S-records until completed
00089Ar 1               ;
00089Ar 1               ;At first entry here, pointer IDY is zero
00089Ar 1               ;At all entries here, a 128 byte block has been received
00089Ar 1               ;The S-record length needs to be calculated, then the proper count moved
00089Ar 1               ;to the SRBUFF location and both pointers (IDX/IDY) updated
00089Ar 1               ;
00089Ar 1  64 D0        XFER_S19	STZ	IDX	;Zero offset to RBUFF
00089Cr 1  A6 D0        S19_LOOP2	LDX	IDX	;Load current offset to RBUFF
00089Er 1  A4 D1        					LDY	IDY	;Get S-Record offset
0008A0r 1  BD 7E 03     S19_LOOP	LDA	RBUFF+2,X	;Get S-Record data
0008A3r 1  99 50 03     					STA	SRBUFF,Y	;Save it to the S-record buffer
0008A6r 1  E8           					INX	;Increment offset to RBUFF
0008A7r 1  E0 81        					CPX	#$81	;Check for end of RBUFF data
0008A9r 1  F0 0E        					BEQ	NXT_FRAME	;If yes, go back and get another frame
0008ABr 1  C8           					INY	;Increment S-Rec size
0008ACr 1  C0 2C        					CPY	#$2C	;Check for size match
0008AEr 1  D0 F0        					BNE	S19_LOOP	;Branch back until done
0008B0r 1  86 D0        					STX	IDX	;Update running offset to RBUFF
0008B2r 1  64 D1        					STZ	IDY	;Reset SRBUFF index pointer
0008B4r 1  20 rr rr     					JSR	SREC_PROC	;Process the S-Record and store in memory
0008B7r 1  80 E3        					BRA	S19_LOOP2	;Branch back and get another record
0008B9r 1  84 D1        NXT_FRAME	STY	IDY	;Save SRBUFF offset
0008BBr 1  80 C5        INCBLK2		BRA	INCBLK	;Increment block and get next frame
0008BDr 1               ;
0008BDr 1  AD 51 03     SREC_PROC	LDA	SRBUFF+1	;Get the Record type character
0008C0r 1  C9 31        					CMP	#'1'	;Check for S1 record
0008C2r 1  F0 6A        					BEQ	S1_PROC	;Process a S1 record
0008C4r 1  C9 39        					CMP	#'9'	;Check for S9 (final) record
0008C6r 1  F0 55        					BEQ	S9_PROC	;Process a S9 record
0008C8r 1  68           SREC_ERR	PLA	;Else, pull return address
0008C9r 1  68           					PLA	;of two bytes from stack
0008CAr 1  80 8D        					BRA	STRT_ERR	;Branch to Xmodem error/exit routine
0008CCr 1               ;
0008CCr 1  AC 53 03     SR_PROC		LDY	SRBUFF+3	;Get record length LS character
0008CFr 1  AD 52 03     					LDA	SRBUFF+2	;Get record length MS character
0008D2r 1  20 rr rr     					JSR	ASC2BIN	;Convert to single byte for length
0008D5r 1  1A           					INC	A	;Add one to length to include checksum
0008D6r 1  85 D4        					STA	TEMP3	;Save record length
0008D8r 1               ;
0008D8r 1               ; If record length is less, than the difference needs to be subtracted from IDX
0008D8r 1               ; which reflects either the last record (S9) or a S1 record of a lesser length
0008D8r 1               ;
0008D8r 1  38           					SEC	;Set carry for subtract
0008D9r 1  A9 14        					LDA	#20	;Get default count
0008DBr 1  E5 D4        					SBC	TEMP3	;Subtract actual length
0008DDr 1  0A           					ASL	A	;Multiply by two for characters pairs
0008DEr 1  85 D3        					STA	TEMP2	;Save it to temp
0008E0r 1               ;
0008E0r 1  38           					SEC	;Set carry for subtract
0008E1r 1  A5 D0        					LDA	IDX	;Get RBUFF index
0008E3r 1  E5 D3        					SBC	TEMP2	;Subtract difference
0008E5r 1  85 D0        					STA	IDX	;Update IDX
0008E7r 1               ;
0008E7r 1  A2 00        SR_COMP		LDX	#$00	;Zero Index
0008E9r 1  A0 00        					LDY	#$00	;Zero Index
0008EBr 1  5A           SR_CMPLP	PHY	;Save Y reg index
0008ECr 1  BC 53 03     					LDY	SRBUFF+3,X	;get LS character
0008EFr 1  BD 52 03     					LDA	SRBUFF+2,X	;Get MS character
0008F2r 1  20 rr rr     					JSR	ASC2BIN	;Convert two ASCII characters to HEX byte
0008F5r 1  7A           					PLY	;Restore Y reg index
0008F6r 1  99 50 03     					STA	SRBUFF,Y	;Store in SRBUFF starting at front
0008F9r 1  E8           					INX	;Increment X reg twice
0008FAr 1  E8           					INX	;points to next character pair
0008FBr 1  C8           					INY	;Increment Y reg once for offset to SRBUFF
0008FCr 1  C6 D4        					DEC	TEMP3	;Decrement character count
0008FEr 1  D0 EB        					BNE	SR_CMPLP	;Branch back until done
000900r 1               ;
000900r 1               ; SRBUFF now has the compressed HEX data, which is:
000900r 1               ; 1 byte for length, 2 bytes for the load address,
000900r 1               ; up to 16 bytes for data and 1 byte checksum
000900r 1               ; Now calculate the checksum and ensure valid S-record content
000900r 1               ;
000900r 1  64 D8        					STZ	CRCLO	;Zero Checksum location
000902r 1  AE 50 03     					LDX	SRBUFF	;Load index with record length
000905r 1  A0 00        					LDY	#$00	;Zero index
000907r 1  18           SR_CHKSM	CLC	;Clear carry for add
000908r 1  B9 50 03     					LDA	SRBUFF,Y	;Get Srec byte
00090Br 1  65 D8        					ADC	CRCLO	;Add in checksum Temp
00090Dr 1  85 D8        					STA	CRCLO	;Update checksum Temp
00090Fr 1  C8           					INY	;Increment offset
000910r 1  CA           					DEX	;Decrement count
000911r 1  D0 F4        					BNE	SR_CHKSM	;Branch back until done
000913r 1               ;
000913r 1  A9 FF        					LDA	#$FF	;Get all bits on
000915r 1  45 D8        					EOR	CRCLO	;Exclusive OR TEMP for one's complement
000917r 1  D9 50 03     					CMP	SRBUFF,Y	;Compare to last byte (which is checksum)
00091Ar 1  D0 AC        					BNE	SREC_ERR	;If bad, exit out
00091Cr 1  60           					RTS	;Return to caller
00091Dr 1               ;
00091Dr 1  20 rr rr     S9_PROC		JSR	SR_PROC	;Process the S-Record and checksum
000920r 1  AD 51 03     					LDA	SRBUFF+1	;Get MSB load address
000923r 1  85 BF        					STA	COMHI	;Store to execution pointer
000925r 1  AD 52 03     					LDA	SRBUFF+2	;Get LSB load address
000928r 1  85 BE        					STA	COMLO	;Store to execution pointer
00092Ar 1  68           					PLA	;Pull return address
00092Br 1  68           					PLA	;second byte
00092Cr 1  80 8D        					BRA	INCBLK2	;Branch back to close out transfer
00092Er 1               ;
00092Er 1  20 rr rr     S1_PROC		JSR	SR_PROC	;Process the S-Record and checksum
000931r 1               ;
000931r 1               ; Valid binary S-Record decoded at SRBUFF
000931r 1               ; Calculate offset from input, add to specified load address
000931r 1               ; and store into memory, then loop back until done
000931r 1               ;
000931r 1               ; Offset is stored in PTR L/H from initial input
000931r 1               ; if no input entered, BUFIDX is zero and PTR L/H is preset to $0800
000931r 1               ; so checking for BUFIDX being zero bypasses adding the offset,
000931r 1               ; if BUFIDX is non zero, then PTR L/H contains the offset address
000931r 1               ; which is added to TGT L/H moving the S-record data to memory
000931r 1               ;
000931r 1  AD 51 03     					LDA	SRBUFF+1	;Get MS load address
000934r 1  85 CB        					STA	TGTH	;Store to target pointer
000936r 1  AD 52 03     					LDA	SRBUFF+2	;Get LS load address
000939r 1  85 CA        					STA	TGTL	;Store to target pointer
00093Br 1  A5 CE        					LDA	BUFIDX	;Check input count for offset required
00093Dr 1  F0 11        					BEQ	NO_OFFSET	;If Zero, no offset was entered
00093Fr 1               ;
00093Fr 1               ; Add in offset contained at PTR L/H to TGT L/H
00093Fr 1               ;
00093Fr 1  18           					CLC	;Clear carry for add
000940r 1  A5 DA        					LDA	PTRL	;Get LS offset
000942r 1  65 CA        					ADC	TGTL	;Add to TGTL address
000944r 1  90 02        					BCC	SKIP_HB	;Skip increment HB if no carry
000946r 1  E6 CB        					INC	TGTH	;Else increment TGTH by one
000948r 1  85 CA        SKIP_HB		STA	TGTL	;Save TGTL
00094Ar 1  A5 DB        					LDA	PTRH	;Get MS offset
00094Cr 1  65 CB        					ADC	TGTH	;Add to TGTH
00094Er 1  85 CB        					STA	TGTH	;Save it
000950r 1               ;
000950r 1               ; Check for first Block and load SRC H/L with load address
000950r 1               ;
000950r 1  A5 DC        NO_OFFSET	LDA	BLKNO	;Get Block number
000952r 1  3A           					DEC	A	;Decrement to test for block one
000953r 1  D0 0E        					BNE	NO_OFFST2	;If not first block, skip around
000955r 1  A5 D0        					LDA	IDX	;Get running count for first block
000957r 1  C9 2C        					CMP	#$2C	;First S-record?
000959r 1  D0 08        					BNE	NO_OFFST2	;If yes, setup load address pointer
00095Br 1  A5 CA        					LDA	TGTL	;Get starting address Lo byte
00095Dr 1  85 C8        					STA	SRCL	;Save it as Source Lo byte
00095Fr 1  A5 CB        					LDA	TGTH	;Get starting address Hi byte
000961r 1  85 C9        					STA	SRCH	;Save it as Source Hi byte
000963r 1               ;
000963r 1  AE 50 03     NO_OFFST2	LDX	SRBUFF	;Get record length
000966r 1  CA           					DEX	;Decrement by 3
000967r 1  CA           					DEX	; to only transfer the data
000968r 1  CA           					DEX	; and not the count and load address
000969r 1  A0 00        					LDY	#$00	;Zero index
00096Br 1  B9 53 03     MVE_SREC	LDA	SRBUFF+3,Y	;Get offset to data in record
00096Er 1  91 CA        					STA	(TGTL),Y	;Store it to memory
000970r 1  C8           					INY	;Increment index
000971r 1  CA           					DEX	;Decrement record count
000972r 1  D0 F7        					BNE	MVE_SREC	;Branch back until done
000974r 1  60           					RTS	;Return to caller
000975r 1               ;
000975r 1               ;[CNTL-R]	Reset System command: Resets system by calling Coldstart routine
000975r 1               ;	Page zero is cleared, vectors and config data re-initialized from ROM
000975r 1               ;	All I/O devices reset from initial ROM parameters, Monitor cold start entered
000975r 1               ;
000975r 1  A9 20        SYS_RST		LDA	#$20	;Get msg "Reset System"
000977r 1  87 D5        					SMB0	CMDFLAG	;Set bit zero
000979r 1  80 02        					BRA	RST_ONLY	;Branch below and handle reset
00097Br 1               ;
00097Br 1               ;[CNTL-Z] Zero command: zero RAM from $0100-$7FFF and Reset
00097Br 1  A9 1F        ZERO			LDA	#$1F	;Get msg "Zero RAM/Reset System"
00097Dr 1  20 rr rr     RST_ONLY	JSR	PROMPT	;Send to terminal
000980r 1  20 rr rr     					JSR	CONTINUE	;Prompt for Continue
000983r 1  8F D5 12     					BBS0	CMDFLAG,DO_COLD	;Branch if reset only
000986r 1  78           					SEI	;Disable IRQs
000987r 1  A9 01        					LDA	#$01	;Initialize address pointer to $0100
000989r 1  85 01        					STA	$01	;Store to pointer high byte
00098Br 1  64 00        					STZ	$00	;Zero address low byte
00098Dr 1  3A           					DEC	A	;LDA #$00
00098Er 1  92 00        ZEROLOOP	STA	($00)	;Write $00 to current address
000990r 1  E6 00        					INC	$00	;Increment address pointer
000992r 1  D0 FA        					BNE	ZEROLOOP
000994r 1  E6 01        					INC	$01
000996r 1  10 F6        					BPL	ZEROLOOP	;LOOP back IF address pointer < $8000
000998r 1  4C rr rr     DO_COLD		JMP	COLDSTRT	;Jump to coldstart vector
00099Br 1               ;
00099Br 1               ;END OF MONITOR CODE
00099Br 1               ;******************************************************************************
00099Br 1               ;
00099Br 1               ;******************************************************************************
00099Br 1               ;START OF MONITOR DATA
00099Br 1               ;******************************************************************************
00099Br 1               ;
00099Br 1               ;* Monitor command & jump table *
00099Br 1               ;
00099Br 1               ;There are two parts to the monitor command and jump table;
00099Br 1               ; first is the list of commands, which are one byte each. Alpha command characters are upper case
00099Br 1               ; second is the 16-bit address table that correspond to the command routines for each command character
00099Br 1               ;
00099Br 1  02           MONCMD		.byte $02 ;[CNTRL-B] Enter EhBasic
00099Cr 1  04           					.byte	$04	;[CNTRL-D]	Disassembler
00099Dr 1  0C           					.byte	$0C	;[CNTRL-L]	Xmodem/CRC Loader
00099Er 1  10           					.byte	$10	;[CNTRL-P]	Program EEPROM
00099Fr 1  11           					.byte	$11	;[CNTRL-Q]	Query Monitor Commands
0009A0r 1  12           					.byte	$12	;[CNTRL-R]	Reset - same as power up
0009A1r 1  14           					.byte	$14	;[CNTRL-T]	Uptime display since reset
0009A2r 1  16           					.byte	$16	;[CNTRL-V]	Display Monitor Version
0009A3r 1  1A           					.byte	$1A	;[CNTRL-Z]	Zero Memory - calls reset
0009A4r 1  28           					.byte	$28	;(	Init Macro
0009A5r 1  29           					.byte	$29	;)	Run Macro
0009A6r 1  2C           					.byte	$2C	;,	Setup Delay parameters
0009A7r 1  2E           					.byte	$2E	;.	Execute Millisecond Delay
0009A8r 1  2F           					.byte	$2F	;/	Execute Long Delay
0009A9r 1  5C           					.byte	$5C	;\	Load and Go Extra Long Delay
0009AAr 1  41           					.byte	$41	;A	Display/Edit A register
0009ABr 1  43           					.byte	$43	;C	Compare memory block
0009ACr 1  44           					.byte	$44	;D	Display Memory contents in HEX/TEXT
0009ADr 1  45           					.byte	$45	;E	Examine/Edit memory
0009AEr 1  46           					.byte	$46	;F	Fill memory block
0009AFr 1  47           					.byte	$47	;G	Go execute to <addr>
0009B0r 1  48           					.byte	$48	;H	Hex byte string search
0009B1r 1  49           					.byte	$49	;I	Input Text string
0009B2r 1  4D           					.byte	$4D	;M	Move memory block
0009B3r 1  50           					.byte	$50	;P	Display/Edit CPU status reg
0009B4r 1  52           					.byte	$52	;R	Display Registers
0009B5r 1  53           					.byte	$53	;S	Display/Edit stack pointer
0009B6r 1  54           					.byte	$54	;T	Text character string search
0009B7r 1  58           					.byte	$58	;X	Display/Edit X register
0009B8r 1  59           					.byte	$59	;Y	Display/Edit Y register
0009B9r 1               ;
0009B9r 1  rr rr        MONTAB		.addr EHBASIC ;[CNTRL-B] $02 Start EhBasic
0009BBr 1  rr rr        					.addr	DSSMBLR	;[CNTRL-D] $04	Disassembler
0009BDr 1  rr rr        					.addr	XMODEM	;[CNTL-L]	$0C	Xmodem download, use send from terminal program
0009BFr 1  rr rr        					.addr	PROGEE ;[CNTL-P]	$10	Program the EEPROM
0009C1r 1  rr rr        					.addr	QUERY	;[CNTL-Q]	$11	Query Monitor Commands
0009C3r 1  rr rr        					.addr	SYS_RST	;[CNTL-R]	$12	Reset CO2Monitor
0009C5r 1  rr rr        					.addr	UPTIME	;[CNTL-T]	$14	System uptime from Reset - sec/min/hr/days
0009C7r 1  rr rr        					.addr	VER	;[CNTL-V]	$16	Display Monitor Version level
0009C9r 1  rr rr        					.addr	ZERO	;[CNTL-Z]	$1A	Zero memory ($0100-$7FFF) then Reset
0009CBr 1  rr rr        					.addr	INIMACRO	; (	$28	Clear keystroke input buffer, reset buffer pointer
0009CDr 1  rr rr        					.addr	RUNMACRO	; )	$29	Run keystroke macro from start of keystroke buffer
0009CFr 1  rr rr        					.addr	SET_DELAY	; .	$2C	Setup Delay Parameters
0009D1r 1  rr rr        					.addr	EXE_MSDLY	; ,	$2E	Perform Millisecond Delay
0009D3r 1  rr rr        					.addr	EXE_LGDLY	;	/	$2F Execute Long Delay
0009D5r 1  rr rr        					.addr	SET_XLDLY	;	\	$5C Load and Go Extra Long Delay
0009D7r 1  rr rr        					.addr	ARG	; A	$41	Examine/change ACCUMULATOR preset/result
0009D9r 1  rr rr        					.addr	CPMVFL	; C	$43	Compare command - new
0009DBr 1  rr rr        					.addr	MDUMP	; D	$44	HEX/TEXT dump from specified memory address
0009DDr 1  rr rr        					.addr	CHANGE	; E	$45	Examine/change a memory location's contents
0009DFr 1  rr rr        					.addr	CPMVFL	; F	$46	Fill a specified memory range with a specified value
0009E1r 1  rr rr        					.addr	GO	; G	$47	Begin program code execution at a specified address
0009E3r 1  rr rr        					.addr	SRCHBYT	; H	$48	Search memory for a specified byte string
0009E5r 1  rr rr        					.addr	TEXT	; I	$49 Input text string into memory
0009E7r 1  rr rr        					.addr	CPMVFL	; M	$4D	Copy a specified memory range to a specified target address
0009E9r 1  rr rr        					.addr	PRG	; P	$50	Examine/change PROCESSOR STATUS REGISTER preset/result
0009EBr 1  rr rr        					.addr	PRSTAT	; R	$52	Display all preset/result contents
0009EDr 1  rr rr        					.addr	SRG	; S	$53	Examine/change STACK POINTER preset/result
0009EFr 1  rr rr        					.addr	SRCHTXT	; T	$54	Search memory for a specified text string
0009F1r 1  rr rr        					.addr	XRG	; X	$58	Examine/change X-REGISTER preset/result
0009F3r 1  rr rr        					.addr	YRG	; Y	$59	Examine/change Y-REGISTER preset/result
0009F5r 1               ;
0009F5r 1               ;******************************************************************************
0009F5r 1               ;C02Monitor message strings used with PROMPT routine, terminated with $00
0009F5r 1               ;
0009F5r 1  20 63 6F 6E  MSG_00		.byte " cont?"
0009F9r 1  74 3F        
0009FBr 1  28 79 2F 6E  MSG_01		.byte	"(y/n)"
0009FFr 1  29           
000A00r 1  00           					.byte $00
000A01r 1  0D 0A        MSG_02		.byte $0D,$0A
000A03r 1  20 20 20     					.byte	"   "
000A06r 1  20 61 64 64  MSG_03		.byte	" addr:"
000A0Ar 1  72 3A        
000A0Cr 1  00           					.byte $00
000A0Dr 1  20 6C 65 6E  MSG_04		.byte " len:"
000A11r 1  3A           
000A12r 1  00           					.byte $00
000A13r 1  20 76 61 6C  MSG_05		.byte " val:"
000A17r 1  3A           
000A18r 1  00           					.byte $00
000A19r 1  20 73 72 63  MSG_06		.byte " src:"
000A1Dr 1  3A           
000A1Er 1  00           					.byte $00
000A1Fr 1  20 74 67 74  MSG_07		.byte " tgt:"
000A23r 1  3A           
000A24r 1  00           					.byte $00
000A25r 1  20 66 69 6E  MSG_08		.byte " find txt:"
000A29r 1  64 20 74 78  
000A2Dr 1  74 3A        
000A2Fr 1  00           					.byte $00
000A30r 1  20 66 69 6E  MSG_09		.byte " find bin:"
000A34r 1  64 20 62 69  
000A38r 1  6E 3A        
000A3Ar 1  00           					.byte $00
000A3Br 1  6E 6F 74 20  MSG_0A		.byte "not "
000A3Fr 1  66 6F 75 6E  MSG_0B		.byte "found"
000A43r 1  64           
000A44r 1  00           					.byte $00
000A45r 1  0D 0A        MSG_0C		.byte $0D,$0A
000A47r 1  73 65 61 72  					.byte "search- "
000A4Br 1  63 68 2D 20  
000A4Fr 1  00           					.byte $00
000A50r 1  0D 0A        MSG_0D		.byte $0D,$0A
000A52r 1  28 6E 29 65  					.byte "(n)ext? "
000A56r 1  78 74 3F 20  
000A5Ar 1  00           					.byte $00
000A5Br 1  53 52 3A 24  MSG_0E		.byte "SR:$"
000A5Fr 1  00           					.byte $00
000A60r 1  53 50 3A 24  MSG_0F		.byte "SP:$"
000A64r 1  00           					.byte $00
000A65r 1  59 52 3A 24  MSG_10		.byte "YR:$"
000A69r 1  00           					.byte $00
000A6Ar 1  58 52 3A 24  MSG_11		.byte "XR:$"
000A6Er 1  00           					.byte $00
000A6Fr 1  41 43 3A 24  MSG_12		.byte "AC:$"
000A73r 1  00           					.byte $00
000A74r 1  0D 0A        MSG_13		.byte	$0D,$0A
000A76r 1  20 20 20 50  					.byte "   PC  AC XR YR SP NV-BDIZC",$0D,$0A
000A7Ar 1  43 20 20 41  
000A7Er 1  43 20 58 52  
000A93r 1  3B 20        					.byte "; "
000A95r 1  00           					.byte $00
000A96r 1  0D 0A        MSG_14		.byte $0D,$0A
000A98r 1  43 30 32 4D  					.byte "C02Monitor (c)2016 K.E.Maier",$07
000A9Cr 1  6F 6E 69 74  
000AA0r 1  6F 72 20 28  
000AB5r 1  0D 0A        MSG_15		.byte $0D,$0A
000AB7r 1  56 65 72 73  					.byte "Version 1.4"
000ABBr 1  69 6F 6E 20  
000ABFr 1  31 2E 34     
000AC2r 1  00           					.byte $00
000AC3r 1  0D 0A        MSG_16		.byte $0D,$0A
000AC5r 1  3B 2D        					.byte ";-"
000AC7r 1  00           					.byte $00
000AC8r 1  20 64 65 6C  MSG_17		.byte	" delay ms:"
000ACCr 1  61 79 20 6D  
000AD0r 1  73 3A        
000AD2r 1  00           					.byte	$00
000AD3r 1  20 6D 75 6C  MSG_18		.byte	" mult:"
000AD7r 1  74 3A        
000AD9r 1  00           					.byte	$00
000ADAr 1  20 64 65 6C  MSG_19		.byte	" delay xl:"
000ADEr 1  61 79 20 78  
000AE2r 1  6C 3A        
000AE4r 1  00           					.byte	$00
000AE5r 1  55 70 74 69  MSG_1A		.byte	"Uptime: "
000AE9r 1  6D 65 3A 20  
000AEDr 1  00           					.byte	$00
000AEEr 1  20 44 61 79  MSG_1B		.byte	" Days, "
000AF2r 1  73 2C 20     
000AF5r 1  00           					.byte	$00
000AF6r 1  20 48 6F 75  MSG_1C		.byte	" Hours, "
000AFAr 1  72 73 2C 20  
000AFEr 1  00           					.byte	$00
000AFFr 1  20 4D 69 6E  MSG_1D		.byte	" Minutes, "
000B03r 1  75 74 65 73  
000B07r 1  2C 20        
000B09r 1  00           					.byte	$00
000B0Ar 1  20 53 65 63  MSG_1E		.byte	" Seconds"
000B0Er 1  6F 6E 64 73  
000B12r 1  00           					.byte	$00
000B13r 1  5A 65 72 6F  MSG_1F		.byte "Zero RAM/"
000B17r 1  20 52 41 4D  
000B1Br 1  2F           
000B1Cr 1  52 65 73 65  MSG_20		.byte	"Reset,"
000B20r 1  74 2C        
000B22r 1  00           					.byte	$00
000B23r 1  50 72 6F 67  MSG_21		.byte	"Program EEPROM",$0D,$0A
000B27r 1  72 61 6D 20  
000B2Br 1  45 45 50 52  
000B33r 1  00           					.byte	$00
000B34r 1  0D 0A        MSG_22		.byte	$0D,$0A
000B36r 1  41 72 65 20  					.byte	"Are you sure? "
000B3Ar 1  79 6F 75 20  
000B3Er 1  73 75 72 65  
000B44r 1  00           					.byte	$00
000B45r 1  0D 0A        MSG_23		.byte	$0D,$0A
000B47r 1  57 72 69 74  					.byte	"Writing EEPROM."
000B4Br 1  69 6E 67 20  
000B4Fr 1  45 45 50 52  
000B56r 1  00           					.byte	$00
000B57r 1  0D 0A        MSG_24		.byte	$0D,$0A
000B59r 1  45 45 50 52  					.byte	"EEPROM Write Complete!"
000B5Dr 1  4F 4D 20 57  
000B61r 1  72 69 74 65  
000B6Fr 1  00           					.byte	$00
000B70r 1  0D 0A        MSG_25		.byte	$0D,$0A
000B72r 1  45 45 50 52  					.byte	"EEPROM Write Failed!",$0D,$0A
000B76r 1  4F 4D 20 57  
000B7Ar 1  72 69 74 65  
000B88r 1  48 61 72 64  					.byte	"Hardware or EEPROM jumper!"
000B8Cr 1  77 61 72 65  
000B90r 1  20 6F 72 20  
000BA2r 1  0D 0A        MSG_26		.byte	$0D,$0A
000BA4r 1  52 54 43 20  					.byte	"RTC time error, check/reset!"
000BA8r 1  74 69 6D 65  
000BACr 1  20 65 72 72  
000BC0r 1  00           					.byte	$00
000BC1r 1  58 4D 4F 44  MSG_27		.byte	"XMODEM Loader, <Esc> to abort, or",$0D,$0A
000BC5r 1  45 4D 20 4C  
000BC9r 1  6F 61 64 65  
000BE4r 1  4C 6F 61 64  					.byte	"Load Address/S-Record Offset:"
000BE8r 1  20 41 64 64  
000BECr 1  72 65 73 73  
000C01r 1  00           					.byte	$00
000C02r 1  0D 0A        MSG_28		.byte	$0D,$0A
000C04r 1  44 6F 77 6E  					.byte	"Download Complete!",$0A
000C08r 1  6C 6F 61 64  
000C0Cr 1  20 43 6F 6D  
000C17r 1  00           					.byte	$00
000C18r 1  0D 0A        MSG_29		.byte	$0D,$0A
000C1Ar 1  44 6F 77 6E  					.byte	"Download Error!",$0A
000C1Er 1  6C 6F 61 64  
000C22r 1  20 45 72 72  
000C2Ar 1  00           					.byte	$00
000C2Br 1  0D 0A        MSG_2A		.byte $0D,$0A
000C2Dr 1  53 2D 52 65  					.byte "S-Record load at:$"
000C31r 1  63 6F 72 64  
000C35r 1  20 6C 6F 61  
000C3Fr 1  00           					.byte $00
000C40r 1  0D 0A        MSG_2B		.byte	$0D,$0A
000C42r 1  44 69 73 61  					.byte	"Disassembly from"
000C46r 1  73 73 65 6D  
000C4Ar 1  62 6C 79 20  
000C52r 1  00           					.byte	$00
000C53r 1  0D 0A 0A     MSG_2C		.byte	$0D,$0A,$0A
000C56r 1  4D 65 6D 6F  					.byte	"Memory Ops: "
000C5Ar 1  72 79 20 4F  
000C5Er 1  70 73 3A 20  
000C62r 1  5B 43 5D 6F  					.byte	"[C]ompare, "
000C66r 1  6D 70 61 72  
000C6Ar 1  65 2C 20     
000C6Dr 1  5B 44 5D 69  					.byte	"[D]isplay, "
000C71r 1  73 70 6C 61  
000C75r 1  79 2C 20     
000C78r 1  5B 45 5D 64  					.byte	"[E]dit, "
000C7Cr 1  69 74 2C 20  
000C80r 1  5B 46 5D 69  					.byte	"[F]ill, "
000C84r 1  6C 6C 2C 20  
000C88r 1  5B 47 5D 6F  					.byte	"[G]o Exec,",$0D,$0A
000C8Cr 1  20 45 78 65  
000C90r 1  63 2C 0D 0A  
000C94r 1  5B 48 5D 65  					.byte	"[H]ex Find, "
000C98r 1  78 20 46 69  
000C9Cr 1  6E 64 2C 20  
000CA0r 1  5B 49 5D 6E  					.byte	"[I]nput Text, "
000CA4r 1  70 75 74 20  
000CA8r 1  54 65 78 74  
000CAEr 1  5B 4D 5D 6F  					.byte	"[M]ove, "
000CB2r 1  76 65 2C 20  
000CB6r 1  5B 54 5D 65  					.byte	"[T]ext Find",$0D,$0A,$0A
000CBAr 1  78 74 20 46  
000CBEr 1  69 6E 64 0D  
000CC4r 1  52 65 67 69  					.byte	"Registers: "
000CC8r 1  73 74 65 72  
000CCCr 1  73 3A 20     
000CCFr 1  52 2C 41 2C  					.byte	"R,A,X,Y,S,P",$0D,$0A,$0A
000CD3r 1  58 2C 59 2C  
000CD7r 1  53 2C 50 0D  
000CDDr 1  54 69 6D 65  					.byte	"Timer: "
000CE1r 1  72 3A 20     
000CE4r 1  2C 3D 20 73  					.byte	",= set ms|mult, "
000CE8r 1  65 74 20 6D  
000CECr 1  73 7C 6D 75  
000CF4r 1  2E 3D 20 65  					.byte	".= exe ms, "
000CF8r 1  78 65 20 6D  
000CFCr 1  73 2C 20     
000CFFr 1  2F 3D 20 65  					.byte	"/= exe ms*mult, "
000D03r 1  78 65 20 6D  
000D07r 1  73 2A 6D 75  
000D0Fr 1  5C 3D 20 65  					.byte	"\= exe (?)*ms*mult",$0D,$0A,$0A
000D13r 1  78 65 20 28  
000D17r 1  3F 29 2A 6D  
000D24r 1  4D 61 63 72  					.byte	"Macro: "
000D28r 1  6F 3A 20     
000D2Br 1  28 3D 20 49  					.byte	"(= Init "
000D2Fr 1  6E 69 74 20  
000D33r 1  29 3D 20 52  					.byte	")= Run",$0D,$0A,$0A
000D37r 1  75 6E 0D 0A  
000D3Br 1  0A           
000D3Cr 1  43 54 52 4C  					.byte	"CTRL[?]: "
000D40r 1  5B 3F 5D 3A  
000D44r 1  20           
000D45r 1  5B 44 5D 69  					.byte	"[D]isassemble, "
000D49r 1  73 61 73 73  
000D4Dr 1  65 6D 62 6C  
000D54r 1  5B 4C 5D 6F  					.byte	"[L]oader, "
000D58r 1  61 64 65 72  
000D5Cr 1  2C 20        
000D5Er 1  5B 50 5D 72  					.byte	"[P]rogram, "
000D62r 1  6F 67 72 61  
000D66r 1  6D 2C 20     
000D69r 1  5B 51 5D 75  					.byte	"[Q]uery Cmds,",$0D,$0A
000D6Dr 1  65 72 79 20  
000D71r 1  43 6D 64 73  
000D78r 1  5B 52 5D 65  					.byte	"[R]eset, "
000D7Cr 1  73 65 74 2C  
000D80r 1  20           
000D81r 1  5B 54 5D 69  					.byte	"[T]ime up, "
000D85r 1  6D 65 20 75  
000D89r 1  70 2C 20     
000D8Cr 1  5B 56 5D 65  					.byte	"[V]ersion, "
000D90r 1  72 73 69 6F  
000D94r 1  6E 2C 20     
000D97r 1  5B 5A 5D 65  					.byte	"[Z]ero RAM",$0A
000D9Br 1  72 6F 20 52  
000D9Fr 1  41 4D 0A     
000DA2r 1  00           					.byte	$00
000DA3r 1  0D 0A        MSG_2D		.byte	$0D,$0A
000DA5r 1  53 68 6F 77  					.byte	"Show Loop count "
000DA9r 1  20 4C 6F 6F  
000DADr 1  70 20 63 6F  
000DB5r 1  00           					.byte	$00
000DB6r 1  0D 0A        MSG_2E		.byte	$0D,$0A
000DB8r 1  4C 6F 6F 70  					.byte	"Loops: "
000DBCr 1  73 3A 20     
000DBFr 1  00           					.byte	$00
000DC0r 1  0D 0A        MSG_2F  .byte     $0D,$0A
000DC2r 1  36 35 43 30          .byte     "65C02 Enhanced BASIC Version 2.22p4C"
000DC6r 1  32 20 45 6E  
000DCAr 1  68 61 6E 63  
000DE6r 1  0D 0A                .byte     $0D,$0A
000DE8r 1  20 5B 43 5D          .byte     " [C]old/[W]arm start?"
000DECr 1  6F 6C 64 2F  
000DF0r 1  5B 57 5D 61  
000DFDr 1  00                   .byte     $00
000DFEr 1               ;
000DFEr 1               MSG_TABLE	;Message table - contains addresses as words of each message sent via the PROMPT routine
000DFEr 1  rr rr        					.addr MSG_00
000E00r 1  rr rr        					.addr	MSG_01
000E02r 1  rr rr        					.addr	MSG_02
000E04r 1  rr rr        					.addr	MSG_03
000E06r 1  rr rr        					.addr	MSG_04
000E08r 1  rr rr        					.addr	MSG_05
000E0Ar 1  rr rr        					.addr	MSG_06
000E0Cr 1  rr rr        					.addr	MSG_07
000E0Er 1  rr rr        					.addr	MSG_08
000E10r 1  rr rr        					.addr	MSG_09
000E12r 1  rr rr        					.addr	MSG_0A
000E14r 1  rr rr        					.addr	MSG_0B
000E16r 1  rr rr        					.addr	MSG_0C
000E18r 1  rr rr        					.addr	MSG_0D
000E1Ar 1  rr rr        					.addr	MSG_0E
000E1Cr 1  rr rr        					.addr	MSG_0F
000E1Er 1  rr rr        					.addr	MSG_10
000E20r 1  rr rr        					.addr	MSG_11
000E22r 1  rr rr        					.addr	MSG_12
000E24r 1  rr rr        					.addr	MSG_13
000E26r 1  rr rr        					.addr	MSG_14
000E28r 1  rr rr        					.addr	MSG_15
000E2Ar 1  rr rr        					.addr	MSG_16
000E2Cr 1  rr rr        					.addr	MSG_17
000E2Er 1  rr rr        					.addr	MSG_18
000E30r 1  rr rr        					.addr	MSG_19
000E32r 1  rr rr        					.addr	MSG_1A
000E34r 1  rr rr        					.addr	MSG_1B
000E36r 1  rr rr        					.addr	MSG_1C
000E38r 1  rr rr        					.addr	MSG_1D
000E3Ar 1  rr rr        					.addr	MSG_1E
000E3Cr 1  rr rr        					.addr	MSG_1F
000E3Er 1  rr rr        					.addr	MSG_20
000E40r 1  rr rr        					.addr	MSG_21
000E42r 1  rr rr        					.addr	MSG_22
000E44r 1  rr rr        					.addr	MSG_23
000E46r 1  rr rr        					.addr	MSG_24
000E48r 1  rr rr        					.addr	MSG_25
000E4Ar 1  rr rr        					.addr	MSG_26
000E4Cr 1  rr rr        					.addr	MSG_27
000E4Er 1  rr rr        					.addr	MSG_28
000E50r 1  rr rr        					.addr	MSG_29
000E52r 1  rr rr        					.addr	MSG_2A
000E54r 1  rr rr        					.addr	MSG_2B
000E56r 1  rr rr        					.addr	MSG_2C
000E58r 1  rr rr        					.addr	MSG_2D
000E5Ar 1  rr rr        					.addr	MSG_2E
000E5Cr 1  rr rr        					.addr	MSG_2F
000E5Er 1               ;
000E5Er 1               ;******************************************************************************
000E5Er 1               ;START OF DISASSEMBLER DATA
000E5Er 1               ;
000E5Er 1               ;Pointer for address mode handlers.
000E5Er 1               ;Each byte contains handler pointer for two opcodes;
000E5Er 1               ;Upper nibble for odd, lower nibble for even
000E5Er 1  26 00 33 3E  HDLR_IDX	.byte	$26,$00,$33,$3E,$02,$10,$88,$8F
000E62r 1  02 10 88 8F  
000E66r 1  C7 B0 34 4E  					.byte	$C7,$B0,$34,$4E,$0A,$10,$89,$9F
000E6Ar 1  0A 10 89 9F  
000E6Er 1  86 00 33 3E  					.byte	$86,$00,$33,$3E,$02,$10,$88,$8F
000E72r 1  02 10 88 8F  
000E76r 1  C7 B0 44 4E  					.byte	$C7,$B0,$44,$4E,$0A,$10,$99,$9F
000E7Ar 1  0A 10 99 9F  
000E7Er 1  06 00 03 3E  					.byte	$06,$00,$03,$3E,$02,$10,$88,$8F
000E82r 1  02 10 88 8F  
000E86r 1  C7 B0 04 4E  					.byte	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
000E8Ar 1  0A 00 09 9F  
000E8Er 1  06 00 33 3E  					.byte	$06,$00,$33,$3E,$02,$10,$B8,$8F
000E92r 1  02 10 B8 8F  
000E96r 1  C7 B0 44 4E  					.byte	$C7,$B0,$44,$4E,$0A,$00,$D9,$9F
000E9Ar 1  0A 00 D9 9F  
000E9Er 1  C6 00 33 3E  					.byte	$C6,$00,$33,$3E,$02,$00,$88,$8F
000EA2r 1  02 00 88 8F  
000EA6r 1  C7 B0 44 5E  					.byte	$C7,$B0,$44,$5E,$0A,$00,$89,$9F
000EAAr 1  0A 00 89 9F  
000EAEr 1  26 20 33 3E  					.byte	$26,$20,$33,$3E,$02,$00,$88,$8F
000EB2r 1  02 00 88 8F  
000EB6r 1  C7 B0 44 5E  					.byte	$C7,$B0,$44,$5E,$0A,$00,$99,$AF
000EBAr 1  0A 00 99 AF  
000EBEr 1  26 00 33 3E  					.byte	$26,$00,$33,$3E,$02,$00,$88,$8F
000EC2r 1  02 00 88 8F  
000EC6r 1  C7 B0 04 4E  					.byte	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
000ECAr 1  0A 00 09 9F  
000ECEr 1  26 00 33 3E  					.byte	$26,$00,$33,$3E,$02,$00,$88,$8F
000ED2r 1  02 00 88 8F  
000ED6r 1  C7 B0 04 4E  					.byte	$C7,$B0,$04,$4E,$0A,$00,$09,$9F
000EDAr 1  0A 00 09 9F  
000EDEr 1               ;
000EDEr 1               ;Disassembler handler table:
000EDEr 1               ;Handler address index: (referenced in table HDLR_IDX)
000EDEr 1  rr rr        HDLR_TAB	.addr	IMPLIED	;$00
000EE0r 1  rr rr        					.addr	ACC_MODE	;$01
000EE2r 1  rr rr        					.addr	ZP_IMED	;$02
000EE4r 1  rr rr        					.addr	ZP_ABS	;$03
000EE6r 1  rr rr        					.addr	ZP_ABS_X	;$04
000EE8r 1  rr rr        					.addr	ZP_ABS_Y	;$05
000EEAr 1  rr rr        					.addr	ZP_IND_X	;$06
000EECr 1  rr rr        					.addr	ZP_IND_Y	;$07
000EEEr 1  rr rr        					.addr	ABSOLUTE	;$08
000EF0r 1  rr rr        					.addr	ABS_X	;$09
000EF2r 1  rr rr        					.addr	ABS_Y	;$0A
000EF4r 1  rr rr        					.addr	INDIRECT	;$0B
000EF6r 1  rr rr        					.addr	REL_BRA	;$0C
000EF8r 1  rr rr        					.addr	IND_ABS_X	;$0D
000EFAr 1  rr rr        					.addr	ZP_XMB	;$0E
000EFCr 1  rr rr        					.addr	ZP_BBX	;$0F
000EFEr 1               ;
000EFEr 1               ;Disassembler mnemonic pointer table. This is indexed by the instruction opcode
000EFEr 1               ; The values in this table are an index to the mnemonic data used to print:
000EFEr 1               MNE_PTAB	;Mnemonic pointer index table
000EFEr 1  1C 4C 00 00  					.byte	$1C,$4C,$00,$00,$82,$4C,$06,$5E,$50,$4C,$06,$00,$82,$4C,$06,$08
000F02r 1  82 4C 06 5E  
000F06r 1  50 4C 06 00  
000F0Er 1  18 4C 4C 00  					.byte	$18,$4C,$4C,$00,$80,$4C,$06,$5E,$22,$4C,$38,$00,$80,$4C,$06,$08
000F12r 1  80 4C 06 5E  
000F16r 1  22 4C 38 00  
000F1Er 1  40 04 00 00  					.byte	$40,$04,$00,$00,$12,$04,$60,$5E,$58,$04,$60,$00,$12,$04,$60,$08
000F22r 1  12 04 60 5E  
000F26r 1  58 04 60 00  
000F2Er 1  14 04 04 00  					.byte	$14,$04,$04,$00,$12,$04,$60,$5E,$6A,$04,$30,$00,$12,$04,$60,$08
000F32r 1  12 04 60 5E  
000F36r 1  6A 04 30 00  
000F3Er 1  64 36 00 00  					.byte	$64,$36,$00,$00,$00,$36,$48,$5E,$4E,$36,$48,$00,$3E,$36,$48,$08
000F42r 1  00 36 48 5E  
000F46r 1  4E 36 48 00  
000F4Er 1  1E 36 36 00  					.byte	$1E,$36,$36,$00,$00,$36,$48,$5E,$26,$36,$54,$00,$00,$36,$48,$08
000F52r 1  00 36 48 5E  
000F56r 1  26 36 54 00  
000F5Er 1  66 02 00 00  					.byte	$66,$02,$00,$00,$7A,$02,$62,$5E,$56,$02,$62,$00,$3E,$02,$62,$08
000F62r 1  7A 02 62 5E  
000F66r 1  56 02 62 00  
000F6Er 1  20 02 02 00  					.byte	$20,$02,$02,$00,$7A,$02,$62,$5E,$6E,$02,$5C,$00,$3E,$02,$62,$08
000F72r 1  7A 02 62 5E  
000F76r 1  6E 02 5C 00  
000F7Er 1  1A 72 00 00  					.byte	$1A,$72,$00,$00,$78,$72,$76,$70,$34,$12,$86,$00,$78,$72,$76,$0A
000F82r 1  78 72 76 70  
000F86r 1  34 12 86 00  
000F8Er 1  0C 72 72 00  					.byte	$0C,$72,$72,$00,$78,$72,$76,$70,$8A,$72,$88,$00,$7A,$72,$7A,$0A
000F92r 1  78 72 76 70  
000F96r 1  8A 72 88 00  
000F9Er 1  46 42 44 00  					.byte	$46,$42,$44,$00,$46,$42,$44,$70,$7E,$42,$7C,$00,$46,$42,$44,$0A
000FA2r 1  46 42 44 70  
000FA6r 1  7E 42 7C 00  
000FAEr 1  0E 42 42 00  					.byte	$0E,$42,$42,$00,$46,$42,$44,$70,$28,$42,$84,$00,$46,$42,$44,$0A
000FB2r 1  46 42 44 70  
000FB6r 1  28 42 84 00  
000FBEr 1  2E 2A 00 00  					.byte	$2E,$2A,$00,$00,$2E,$2A,$30,$70,$3C,$2A,$32,$8C,$2E,$2A,$30,$0A
000FC2r 1  2E 2A 30 70  
000FC6r 1  3C 2A 32 8C  
000FCEr 1  16 2A 2A 00  					.byte	$16,$2A,$2A,$00,$00,$2A,$30,$70,$24,$2A,$52,$74,$00,$2A,$30,$0A
000FD2r 1  00 2A 30 70  
000FD6r 1  24 2A 52 74  
000FDEr 1  2C 68 00 00  					.byte	$2C,$68,$00,$00,$2C,$68,$38,$70,$3A,$68,$4A,$00,$2C,$68,$38,$0A
000FE2r 1  2C 68 38 70  
000FE6r 1  3A 68 4A 00  
000FEEr 1  10 68 68 00  					.byte	$10,$68,$68,$00,$00,$68,$38,$70,$6C,$68,$5A,$00,$00,$68,$38,$0A
000FF2r 1  00 68 38 70  
000FF6r 1  6C 68 5A 00  
000FFEr 1               ;
000FFEr 1               DIS_NMEM	;Mnemonic compressed table
000FFEr 1               ;	Uses two bytes per 3-character Mnemonic. 5-bits per character uses 15-bit total
000FFEr 1               ;	Characters are left to right. 5-bits shifted into A reg, add in $3F and print
000FFEr 1               ;	"?" starts with "00000", "A" starts with "00010", "B" starts with "00011", etc.
000FFEr 1               ;
000FFEr 1               ; A	00010		B	00011		C	00100		D	00101		E	00110		F	00111		G	01000		H	01001
000FFEr 1               ;	I	01010		J	01011		K	01100		L	01101		M	01110		N	01111		O	10000		P	10001
000FFEr 1               ;	Q	10010		R	10011		S	10100		T	10101		U	10110		V	10111		W	11000		X	11001
000FFEr 1               ;	Y	11010		Z	11011
000FFEr 1               ;
000FFEr 1  00 00        					.byte $00, $00    ; %0000000000000000	;???	$00
001000r 1  11 48        					.byte $11, $48    ; %0001000101001000	;ADC	$02
001002r 1  13 CA        					.byte $13, $CA    ; %0001001111001010	;AND	$04
001004r 1  15 1A        					.byte $15, $1A    ; %0001010100011010	;ASL	$06
001006r 1  18 E6        					.byte $18, $E6    ; %0001100011100110	;BBR	$08
001008r 1  18 E8        					.byte $18, $E8    ; %0001100011101000	;BBS	$0A
00100Ar 1  19 08        					.byte $19, $08    ; %0001100100001000	;BCC	$0C
00100Cr 1  19 28        					.byte $19, $28    ; %0001100100101000	;BCS	$0E
00100Er 1  19 A4        					.byte $19, $A4    ; %0001100110100100	;BEQ	$10
001010r 1  1A AA        					.byte $1A, $AA    ; %0001101010101010	;BIT	$12
001012r 1  1B 94        					.byte $1B, $94    ; %0001101110010100	;BMI	$14
001014r 1  1B CC        					.byte $1B, $CC    ; %0001101111001100	;BNE	$16
001016r 1  1C 5A        					.byte $1C, $5A    ; %0001110001011010	;BPL	$18
001018r 1  1C C4        					.byte $1C, $C4    ; %0001110011000100	;BRA	$1A
00101Ar 1  1C D8        					.byte $1C, $D8    ; %0001110011011000	;BRK	$1C
00101Cr 1  1D C8        					.byte $1D, $C8    ; %0001110111001000	;BVC	$1E
00101Er 1  1D E8        					.byte $1D, $E8    ; %0001110111101000	;BVS	$20
001020r 1  23 48        					.byte $23, $48    ; %0010001101001000	;CLC	$22
001022r 1  23 4A        					.byte $23, $4A    ; %0010001101001010	;CLD	$24
001024r 1  23 54        					.byte $23, $54    ; %0010001101010100	;CLI	$26
001026r 1  23 6E        					.byte $23, $6E    ; %0010001101101110	;CLV	$28
001028r 1  23 A2        					.byte $23, $A2    ; %0010001110100010	;CMP	$2A
00102Ar 1  24 72        					.byte $24, $72    ; %0010010001110010	;CPX	$2C
00102Cr 1  24 74        					.byte $24, $74    ; %0010010001110100	;CPY	$2E
00102Er 1  29 88        					.byte $29, $88    ; %0010100110001000	;DEC	$30
001030r 1  29 B2        					.byte $29, $B2    ; %0010100110110010	;DEX	$32
001032r 1  29 B4        					.byte $29, $B4    ; %0010100110110100	;DEY	$34
001034r 1  34 26        					.byte $34, $26    ; %0011010000100110	;EOR	$36
001036r 1  53 C8        					.byte $53, $C8    ; %0101001111001000	;INC	$38
001038r 1  53 F2        					.byte $53, $F2    ; %0101001111110010	;INX	$3A
00103Ar 1  53 F4        					.byte $53, $F4    ; %0101001111110100	;INY	$3C
00103Cr 1  5B A2        					.byte $5B, $A2    ; %0101101110100010	;JMP	$3E
00103Er 1  5D 26        					.byte $5D, $26    ; %0101110100100110	;JSR	$40
001040r 1  69 44        					.byte $69, $44    ; %0110100101000100	;LDA	$42
001042r 1  69 72        					.byte $69, $72    ; %0110100101110010	;LDX	$44
001044r 1  69 74        					.byte $69, $74    ; %0110100101110100	;LDY	$46
001046r 1  6D 26        					.byte $6D, $26    ; %0110110100100110	;LSR	$48
001048r 1  7C 22        					.byte $7C, $22    ; %0111110000100010	;NOP	$4A
00104Ar 1  84 C4        					.byte $84, $C4    ; %1000010011000100	;ORA	$4C
00104Cr 1  8A 44        					.byte $8A, $44    ; %1000101001000100	;PHA	$4E
00104Er 1  8A 62        					.byte $8A, $62    ; %1000101001100010	;PHP	$50
001050r 1  8A 72        					.byte $8A, $72    ; %1000101001110010	;PHX	$52
001052r 1  8A 74        					.byte $8A, $74    ; %1000101001110100	;PHY	$54
001054r 1  8B 44        					.byte $8B, $44    ; %1000101101000100	;PLA	$56
001056r 1  8B 62        					.byte $8B, $62    ; %1000101101100010	;PLP	$58
001058r 1  8B 72        					.byte $8B, $72    ; %1000101101110010	;PLX	$5A
00105Ar 1  8B 74        					.byte $8B, $74    ; %1000101101110100	;PLY	$5C
00105Cr 1  9B 86        					.byte $9B, $86    ; %1001101110000110	;RMB	$5E
00105Er 1  9C 1A        					.byte $9C, $1A    ; %1001110000011010	;ROL	$60
001060r 1  9C 26        					.byte $9C, $26    ; %1001110000100110	;ROR	$62
001062r 1  9D 54        					.byte $9D, $54    ; %1001110101010100	;RTI	$64
001064r 1  9D 68        					.byte $9D, $68    ; %1001110101101000	;RTS	$66
001066r 1  A0 C8        					.byte $A0, $C8    ; %1010000011001000	;SBC	$68
001068r 1  A1 88        					.byte $A1, $88    ; %1010000110001000	;SEC	$6A
00106Ar 1  A1 8A        					.byte $A1, $8A    ; %1010000110001010	;SED	$6C
00106Cr 1  A1 94        					.byte $A1, $94    ; %1010000110010100	;SEI	$6E
00106Er 1  A3 86        					.byte $A3, $86    ; %1010001110000110	;SMB	$70
001070r 1  A5 44        					.byte $A5, $44    ; %1010010101000100	;STA	$72
001072r 1  A5 62        					.byte $A5, $62    ; %1010010101100010	;STP	$74
001074r 1  A5 72        					.byte $A5, $72    ; %1010010101110010	;STX	$76
001076r 1  A5 74        					.byte $A5, $74    ; %1010010101110100	;STY	$78
001078r 1  A5 76        					.byte $A5, $76    ; %1010010101110110	;STZ	$7A
00107Ar 1  A8 B2        					.byte $A8, $B2    ; %1010100010110010	;TAX	$7C
00107Cr 1  A8 B4        					.byte $A8, $B4    ; %1010100010110100	;TAY	$7E
00107Er 1  AC E8        					.byte $AC, $E8    ; %1010110011101000	;TRB	$80
001080r 1  AD 06        					.byte $AD, $06    ; %1010110100000110	;TSB	$82
001082r 1  AD 32        					.byte $AD, $32    ; %1010110100110010	;TSX	$84
001084r 1  AE 44        					.byte $AE, $44    ; %1010111001000100	;TXA	$86
001086r 1  AE 68        					.byte $AE, $68    ; %1010111001101000	;TXS	$88
001088r 1  AE 84        					.byte $AE, $84    ; %1010111010000100	;TYA	$8A
00108Ar 1  C0 94        					.byte $C0, $94    ; %1100000010010100	;WAI	$8C
00108Cr 1               ;
00108Cr 1               ;END OF DISASSEMBLER DATA
00108Cr 1               ;******************************************************************************
00108Cr 1               ;END OF MONITOR DATA
00108Cr 1               ;******************************************************************************
00108Cr 1               ;
00108Cr 1               ;******************************************************************************
00108Cr 1               ;				.org	$F800	;2KB reserved for BIOS, I/O device selects (256 bytes)
00108Cr 1               ;******************************************************************************
00108Cr 1               ;START OF BIOS CODE
00108Cr 1               ;******************************************************************************
00108Cr 1               ; C02BIOS version used here is 1.4
00108Cr 1               ;
00108Cr 1               ; Contains the base BIOS routines in top 1KB of EEPROM
00108Cr 1               ; - Pages $F8/$F9 512 bytes for BIOS (65C51/65C22), NMI Panic routine
00108Cr 1               ; - Pages $FA-$FD reserved for BIOS expansion
00108Cr 1               ; - Page $FE reserved for HW (8-I/O devices, 32 bytes wide)
00108Cr 1               ; - Page ($FF) JMP table, CPU startup, 64 bytes Soft Vectors and HW Config data
00108Cr 1               ;		- does I/O init and handles NMI/BRK/IRQ pre-/post-processing routines
00108Cr 1               ;		- sends BIOS message string to console
00108Cr 1               ;	- Additional code added to handle XMODEM transfers
00108Cr 1               ;		- allows a null character to be received into the buffer
00108Cr 1               ;		- CRC bytes can be zero, original code would invoke BRK routine
00108Cr 1               ;		- Uses the XMFLAG flag which is set/cleared during Xmodem xfers
00108Cr 1               ;		- Now uses BBR instruction to check XMFLAG - saves a byte
00108Cr 1               ;		-	Now uses BBR instruction to check BRK condition - saves a byte
00108Cr 1               ; - BEEP moved to main monitor code, JMP entry replaced with CHRIN_NW
00108Cr 1               ; - Input/Feedback from "BDD" - modified CHR-I/O routines - saves 12 bytes
00108Cr 1               ;******************************************************************************
00108Cr 1               ;	The following 16 functions are provided by BIOS and available via the JMP
00108Cr 1               ;	Table as the last 16 entries from $FF48 - $FF75 as:
00108Cr 1               ;	$FF48 CHRIN_NW (character input from console, no waiting, set carry if none)
00108Cr 1               ;	$FF4B CHRIN (character input from console)
00108Cr 1               ;	$FF4E CHROUT (character output to console)
00108Cr 1               ;	$FF51 SETDLY (set delay value for milliseconds and 16-bit counter)
00108Cr 1               ;	$FF54 MSDELAY (execute millisecond delay 1-256 milliseconds)
00108Cr 1               ;	$FF57 LGDELAY (execute long delay; millisecond delay * 16-bit count)
00108Cr 1               ;	$FF5A XLDELAY (execute extra long delay; 8-bit count * long delay)
00108Cr 1               ;	$FF5D SETPORT (set VIA port A or B for input or output)
00108Cr 1               ;	$FF60 RDPORT (read from VIA port A or B)
00108Cr 1               ;	$FF63 WRPORT (write to VIA port A or B)
00108Cr 1               ;	$FF66 INITVEC (initialize soft vectors at $0300 from ROM)
00108Cr 1               ;	$FF69 INITCFG (initialize soft config values at $0320 from ROM)
00108Cr 1               ;	$FF6C INITCON (initialize 65C51 console 19.2K, 8-N-1 RTS/CTS)
00108Cr 1               ;	$FF6F INITVIA (initialize 65C22 default port, timers and interrupts)
00108Cr 1               ;	$FF72 MONWARM (warm start Monitor - jumps to page $03)
00108Cr 1               ;	$FF75 MONCOLD (cold start Monitor - jumps to page $03)
00108Cr 1               ;******************************************************************************
00108Cr 1               ; Character In and Out routines for Console I/O buffer
00108Cr 1               ;******************************************************************************
00108Cr 1               ;
00108Cr 1               ;CHRIN routines
00108Cr 1               ;CHRIN_NW uses CHRIN, returns if a character is not available from the buffer
00108Cr 1               ; with carry flag clear, else returns with character in A reg and carry flag set
00108Cr 1               ;CHRIN waitd for a character to be in the buffer, then returns with carry flag set
00108Cr 1               ;	receive is IRQ driven / buffered with a fixed size of 128 bytes
00108Cr 1               ;
00108Cr 1  18           CHRIN_NW	CLC	;Clear Carry flag for no character (2)
00108Dr 1  A5 E7        					LDA	ICNT	;Get character count (3)
00108Fr 1  D0 05        					BNE	GET_CH	;Branch if buffer is not empty (2/3)
001091r 1  60           					RTS	;and return to caller (6)
001092r 1               ;
001092r 1               ;CHRIN waits for a character and retuns with it in the A reg
001092r 1               ;
001092r 1  A5 E7        CHRIN			LDA	ICNT	;Get character count (3)
001094r 1  F0 FC        					BEQ	CHRIN	;If zero (no character, loop back) (2/3)
001096r 1               ;
001096r 1  5A           GET_CH		PHY	;Save Y reg (3)
001097r 1  A4 E8        					LDY	IHEAD	;Get the buffer head pointer (3)
001099r 1  B9 00 02     					LDA	IBUF,Y	;Get the character from the buffer (4)
00109Cr 1               ;
00109Cr 1  E6 E8        					INC	IHEAD	;Increment head pointer (5)
00109Er 1  77 E8        					RMB7	IHEAD	;Strip off bit 7, 128 bytes only (5)
0010A0r 1               ;
0010A0r 1  C6 E7        					DEC	ICNT	;Decrement the buffer count (5)
0010A2r 1  7A           					PLY	;Restore Y Reg (4)
0010A3r 1  38           					SEC	;Set Carry flag for character available (2)
0010A4r 1  60           					RTS	;Return to caller with character in A reg (6)
0010A5r 1               ;
0010A5r 1               ;CHROUT routine: takes the character in the A reg and places it in the xmit buffer
0010A5r 1               ; the character sent in the A reg is preserved on exit
0010A5r 1               ;	transmit is IRQ driven / buffered with a fixed size of 128 bytes
0010A5r 1               ;
0010A5r 1               ;	- 8/10/2014 - modified this routine to always set the Xmit interrupt active with each
0010A5r 1               ;	character placed into the output buffer. There appears to be a highly intermittant bug
0010A5r 1               ;	in both the 6551 and 65C51 where the Xmit interrupt turns itself off, the code itself
0010A5r 1               ;	is not doing it as the OIE flag was never reset and this only happens in the IRQ routine
0010A5r 1               ;	The I/O and service routines now appear to work in a stable manner on all 6551 and 65C51
0010A5r 1               ;	Note: OIE flag no longer needed/used due to bug workaround
0010A5r 1               ;
0010A5r 1  5A           CHROUT		PHY	;save Y reg	(3)
0010A6r 1  A4 EA        OUTCH			LDY	OCNT	;get character output count in buffer	(3)
0010A8r 1  30 FC        					BMI	OUTCH	;check against limit, loop back if full	(2/3)
0010AAr 1               ;
0010AAr 1  A4 EC        					LDY	OTAIL	;Get the buffer tail pointer	(3)
0010ACr 1  99 80 02     					STA	OBUF,Y	;Place character in the buffer	(5)
0010AFr 1               ;
0010AFr 1  E6 EC        					INC	OTAIL	;Increment Tail pointer (5)
0010B1r 1  77 EC        					RMB7	OTAIL	;Strip off bit 7, 128 bytes only (5)
0010B3r 1  E6 EA        					INC	OCNT	;Increment character count	(5)
0010B5r 1               ;
0010B5r 1  A0 05        					LDY	#$05	;Get mask for xmit on	(2)
0010B7r 1  8C 02 90     					STY	SIOCOM	;Turn on xmit irq	(4)
0010BAr 1               ;
0010BAr 1  7A           OUTC2			PLY	;Restore Y reg	(4)
0010BBr 1  60           					RTS	;Return	to caller (6)
0010BCr 1               ;
0010BCr 1               ;******************************************************************************
0010BCr 1               ;SET DELAY routine
0010BCr 1               ; This routine sets up the MSDELAY values and can also set the Long Delay variable
0010BCr 1               ; On entry, A reg = millisecond count, X reg = High multipler, Y reg = Low multipler
0010BCr 1               ;	these values are used by the EXE_MSDLY and EXE_LGDLY routines
0010BCr 1               ;	values for MSDELAY are $00-$FF ($00 = 256 times)
0010BCr 1               ;	values for Long Delay are $0000-$FFFF (0-65535 times)
0010BCr 1               ;	longest delay is 65,535*256*1ms = 16,776,960 * 0.001 = 16,776.960 seconds
0010BCr 1               ;
0010BCr 1  85 F6        SET_DLY		STA	SETIM	;Save millisecond count (3)
0010BEr 1  84 F7        					STY	DELLO	;Save Low multipler (3)
0010C0r 1  86 F8        					STX	DELHI	;Save High Multipler (3)
0010C2r 1  60           					RTS	;Return to caller (6)
0010C3r 1               ;
0010C3r 1               ;EXE MSDELAY routine
0010C3r 1               ;	This routine is the core delay routine
0010C3r 1               ;	It sets the count value from SETIM variable, enables the MATCH flag, then starts
0010C3r 1               ;	Timer 2 and waits for the IRQ routine to decrement to zero and clear the MATCH flag
0010C3r 1               ;	note: 3 clock cycles (JMP table) to get here on a standard call
0010C3r 1               ;	- 11 clock cycles to start T2, 15 clock cycles to return after MATCH cleared
0010C3r 1               ;	- starting T2 first to help normalize overall delay time
0010C3r 1               ;	- total of 37 clock cycles overhead in this routine
0010C3r 1               ;
0010C3r 1  48           EXE_MSDLY	PHA	;Save A Reg (3)
0010C4r 1  AD 29 03     					LDA	LOAD_6522+$07	;Get T2H value (4)
0010C7r 1  8D 09 A0     					STA	Via1T2CH	;Reload T2 and enable interrupt (4)
0010CAr 1  F7 F5        					SMB7	MATCH	;Set MATCH flag bit (5)
0010CCr 1  A5 F6        					LDA	SETIM	;Get delay seed value (3)
0010CEr 1  85 F4        					STA	MSDELAY	;Set MS delay value (3)
0010D0r 1               ;
0010D0r 1  FF F5 FD     MATCH_LP	BBS7	MATCH,MATCH_LP	;Test MATCH flag, loop until cleared (5)
0010D3r 1  68           					PLA	;Restore A Reg (4)
0010D4r 1  60           					RTS	;Return to caller (6)
0010D5r 1               ;
0010D5r 1               ;EXE LONG Delay routine
0010D5r 1               ;	This routine is the 16-bit multiplier for the MS DELAY routine
0010D5r 1               ;	It loads the 16-bit count from DELLO/DELHI, then loops the MSDELAY
0010D5r 1               ;	routine until the 16-bit count is decremented to zero
0010D5r 1               ;
0010D5r 1  DA           EXE_LGDLY	PHX	;Save X Reg (4)
0010D6r 1  5A           					PHY	;Save Y Reg (4)
0010D7r 1  A6 F8        					LDX	DELHI	;Get high byte count (3)
0010D9r 1  E8           					INX	;Increment by one (checks for $00 vs $FF) (2)
0010DAr 1  A4 F7        					LDY	DELLO	;Get low byte count (3)
0010DCr 1  F0 06        					BEQ	SKP_DLL	;If zero, skip to high count (2/3)
0010DEr 1  20 rr rr     DO_DLL		JSR	EXE_MSDLY	;Call millisecond delay (6)
0010E1r 1  88           					DEY	;Decrement low count (2)
0010E2r 1  D0 FA        					BNE	DO_DLL	;Branch back until done (2/3)
0010E4r 1               ;
0010E4r 1  CA           SKP_DLL		DEX	;Decrement high byte index (2)
0010E5r 1  D0 F7        					BNE	DO_DLL	;Loop back to DLL (will run 256 times) (2/3)
0010E7r 1  7A           					PLY	;Restore Y Reg (3)
0010E8r 1  FA           					PLX	;Restore X Reg (3)
0010E9r 1  60           					RTS	;Return to caller (6)
0010EAr 1               ;
0010EAr 1               ;EXE EXTRA LONG Delay routine
0010EAr 1               ;	This routine uses XDL variable as an 8-bit count
0010EAr 1               ;	and calls the EXE LONG Delay routine XDL times
0010EAr 1               ;	- On entry, XDL contains the number of interations
0010EAr 1  20 rr rr     EXE_XLDLY	JSR	EXE_LGDLY	;Call the Long Delay routine (6)
0010EDr 1  C6 F9        					DEC	XDL	;Decrement count (5)
0010EFr 1  D0 F9        					BNE	EXE_XLDLY	;Loop back until XDL times out (2/3)
0010F1r 1  60           					RTS	;Done, return to caller (6)
0010F2r 1               ;
0010F2r 1               ;******************************************************************************
0010F2r 1               ; I/O PORT routines for 6522
0010F2r 1               ;	- Allows port A or B setup for input or output
0010F2r 1               ;	- Allows data to be read from Port A or B
0010F2r 1               ;	- Allows data to be written to Port A or B
0010F2r 1               ;	- Routines are Non-buffered and no HW handshaking
0010F2r 1               ;	- Page zero variables are used: IO_DIR, IO_IN, IO_OUT
0010F2r 1               ;
0010F2r 1               ;	6522 Port Config routine
0010F2r 1               ;	- Allows Port A or B to be configured for input or output
0010F2r 1               ;	- On entry, X reg contains port number (1=A, 0=B)
0010F2r 1               ;	- A reg contains config mask; bit=0 for Input, bit=1 for Output
0010F2r 1               ;	- on exit, A reg contain Port DDR value, X reg contains port #
0010F2r 1               ;	- Carry set if error, cleared if OK
0010F2r 1               ;
0010F2r 1  9D 02 A0     SET_PORT	STA	Via1DDRB,X	;Store config Mask to the correct port (5)
0010F5r 1  85 FB        					STA	IO_DIR	;Save Mask for compare (3)
0010F7r 1  BD 02 A0     					LDA	Via1DDRB,X	;Load config Mask back from port (4)
0010FAr 1  C5 FB        					CMP	IO_DIR	;Compare to config MASK (3)
0010FCr 1  B0 02        					BCS	PORT_OK	;Branch if same (2/3)
0010FEr 1  38           					SEC	;Set Carry for bad compare (2)
0010FFr 1  60           					RTS	;Return to caller (6)
001100r 1  18           PORT_OK		CLC	;Clear Carry flag for no error (2)
001101r 1  60           					RTS	;Return to caller (6)
001102r 1               ;
001102r 1               ;	Port Input routine
001102r 1               ;	- On entry, X reg contains port number (1=A, 0=B)
001102r 1               ;	- On exit, A reg contains read data, X reg contains port #
001102r 1               ;	- Carry set if error on read, cleared if OK
001102r 1               ;	- Requested Port is read twice and compared for error,
001102r 1               ;	- this implies port data input does not change too quickly
001102r 1               ;
001102r 1  BD 00 A0     IN_PORT		LDA	Via1PRB,X	;Read Port data (4)
001105r 1  85 FC        					STA	IO_IN	;Save Read data (3)
001107r 1  BD 00 A0     					LDA	Via1PRB,X	;Read Port a second time (4)
00110Ar 1  C5 FC        					CMP	IO_IN	;Compare against previous read (3)
00110Cr 1  B0 F2        					BCS	PORT_OK	;Branch if same (2/3)
00110Er 1  38           					SEC	;Set Carry for bad compare (2)
00110Fr 1  60           					RTS	;Return to caller (6)
001110r 1               ;
001110r 1               ;	Port Output routine
001110r 1               ;	- On entry, X reg contains port number (1=A, 0=B)
001110r 1               ;	- A reg contain data to write to port
001110r 1               ;	- On exit, A reg contains Port data, X reg contains port #
001110r 1               ;	- Carry set if error on write, cleared if OK
001110r 1               ;
001110r 1  9D 00 A0     OUT_PORT	STA	Via1PRB,X	;Write Port data (5)
001113r 1  85 FD        					STA	IO_OUT	;Save data to output to port (3)
001115r 1  BD 00 A0     					LDA	Via1PRB,X	;Read Port data back (4)
001118r 1  C5 FD        					CMP	IO_OUT	;Compare against previous read (3)
00111Ar 1  B0 E4        					BCS	PORT_OK	;Branch if same (2/3)
00111Cr 1  38           					SEC	;Set Carry for bad compare (2)
00111Dr 1  60           					RTS	;Return to caller (6)
00111Er 1               ;
00111Er 1               ;******************************************************************************
00111Er 1               ;
00111Er 1               ;START OF PANIC ROUTINE
00111Er 1               ; The Panic routine is for debug of system problems, i.e., a crash
00111Er 1               ; The design requires a debounced NMI trigger button which is manually operated
00111Er 1               ; when the system crashes or malfunctions, press the NMI (panic) button
00111Er 1               ; The NMI vectored routine will perform the following tasks:
00111Er 1               ; 1- Save registers in page $00
00111Er 1               ; 2- Save pages $00, $01, $02 and $03 at location $0400-$07FF
00111Er 1               ; 3- Overlay the I/O page ($FE) at location $0780
00111Er 1               ; 4- Zero I/O buffer pointers
00111Er 1               ; Call the ROM routines to init the vectors and config data (page $03)
00111Er 1               ; Call ROM routines to init the 6551 and 6522 devices
00111Er 1               ; Restart the Monitor via warm start vector
00111Er 1               ; No memory is cleared except the required pointers to restore the system
00111Er 1               ;	- suggest invoking the Register command afterwards to get the details saved
00111Er 1               ;
00111Er 1               NMI_VECTOR	;This is the ROM start for NMI Panic handler
00111Er 1  85 E6        					STA	AREG	;Save A Reg (3)
001120r 1  86 E5        					STX	XREG	;Save X Reg (3)
001122r 1  84 E4        					STY	YREG	;Save Y Reg (3)
001124r 1  68           					PLA	;Get Processor Status 	      (3)
001125r 1  85 E2        					STA	PREG	;Save in PROCESSOR STATUS preset/result (3)
001127r 1  BA           					TSX	;Get Stack pointer (2)
001128r 1  86 E3        					STX	SREG	;Save STACK POINTER (3)
00112Ar 1  68           					PLA	;Pull RETURN address from STACK (3)
00112Br 1  85 E0        					STA	PCL	;Store Low byte (3)
00112Dr 1  68           					PLA	;Pull high byte (3)
00112Er 1  85 E1        					STA	PCH	;Store High byte (3)
001130r 1               ;
001130r 1  A0 00        					LDY	#$00	;Zero Y reg (2)
001132r 1  A2 04        					LDX	#$04	;Set index to 4 pages (2)
001134r 1  86 03        					STX	$03	;Set to high order (3)
001136r 1  64 02        					STZ	$02	;Zero remaining pointers (3)
001138r 1  64 01        					STZ	$01 ;(3)
00113Ar 1  64 00        					STZ	$00 ;(3)
00113Cr 1               ;
00113Cr 1  B1 00        PLP0			LDA	($00),Y	;get byte (4)
00113Er 1  91 02        					STA	($02),Y	;store byte (6)
001140r 1  88           					DEY	;Decrement index (2)
001141r 1  D0 F9        					BNE	PLP0	;Loop back till done (2/3)
001143r 1               ;
001143r 1  E6 03        					INC	$03	;Increment page address (5)
001145r 1  E6 01        					INC	$01	;Increment page address (5)
001147r 1  CA           					DEX	;Decrement page index (2)
001148r 1  D0 F2        					BNE	PLP0	;Branch back and do next page (2/3)
00114Ar 1               ;
00114Ar 1  BD 00 FE     IO_LOOP		LDA	$FE00,X	;Get I/O Page (X reg already at #$00) (4)
00114Dr 1  9D 80 07     					STA	$0780,X	;Overlay I/O page to Vector Save (5)
001150r 1  E8           					INX	;Increment index (2)
001151r 1  10 F7        					BPL	IO_LOOP	;Loop back until done (128 bytes) (2/3)
001153r 1               ;
001153r 1  A2 06        					LDX	#$06	;Get count of 6 (2)
001155r 1  74 E6        PAN_LP1		STZ	ICNT-1,X	;Zero out console I/O pointers (4)
001157r 1  CA           					DEX	;Decrement index (2)
001158r 1  D0 FB        					BNE	PAN_LP1	;Branch back till done (2/3)
00115Ar 1               ;
00115Ar 1  20 rr rr     					JSR	INIT_PG03	;Xfer default Vectors/HW Config to $0300 (6)
00115Dr 1  20 rr rr     					JSR	INIT_IO	;Init I/O - Console, Timers, Ports (6)
001160r 1               ;
001160r 1  6C 06 03     					JMP	(NMIRTVEC0)	;Jump to Monitor Warm Start Vector (5)
001163r 1               ;
001163r 1               ;*************************************
001163r 1               ;* BRK/IRQ Interrupt service routine *
001163r 1               ;*************************************
001163r 1               ;
001163r 1               ;The pre-process routine located in page $FF soft-vectors to here:
001163r 1               ;	The following routines handle BRK and IRQ
001163r 1               ;	The BRK handler saves CPU details for register display
001163r 1               ;	- A Monitor can provide a disassembly of the last executed instruction
001163r 1               ;	- An ASCII null character ($00) is also handled here
001163r 1               ;
001163r 1               ;6551 handler
001163r 1               ;	The 6551 IRQ routine handles both transmit and receive via IRQ
001163r 1               ;	- each has it's own 128 circular buffer
001163r 1               ;	- Xmit IRQ is controlled by the handler and the CHROUT routine
001163r 1               ;
001163r 1               ;6522 handler
001163r 1               ; The 6522 IRQ routine handles Timer1 interrupts used for a RTC
001163r 1               ;	- resolution is set for 4ms (250 interrupts per second)
001163r 1               ;	- recommended CPU clock rate is 2MHz minimum
001163r 1               ; Timer2 provides an accurate delay with resolution to 1ms
001163r 1               ;	- timer service/match routine are IRQ driven with dedicated handler
001163r 1               ;
001163r 1  58           BREAKEY		CLI	;Enable IRQ (2)
001164r 1               ;
001164r 1  7A           BRKINSTR0	PLY	;Restore Y reg (4)
001165r 1  FA           					PLX	;Restore X Reg (4)
001166r 1  68           					PLA	;Restore A Reg (4)
001167r 1  85 E6        					STA	AREG	;Save A Reg (3)
001169r 1  86 E5        					STX	XREG	;Save X Reg (3)
00116Br 1  84 E4        					STY	YREG	;Save Y Reg (3)
00116Dr 1  68           					PLA	;Get Processor Status (4)
00116Er 1  85 E2        					STA	PREG	;Save in PROCESSOR STATUS preset/result (2)
001170r 1  BA           					TSX	;Xfrer STACK pointer to X reg (2)
001171r 1  86 E3        					STX	SREG	;Save STACK pointer (4)
001173r 1               ;
001173r 1  FA           					PLX	;Pull Low RETURN address from STACK then save it (4)
001174r 1  86 E0        					STX	PCL	;Store program counter Low byte (3)
001176r 1  86 C0        					STX	INDEXL	;Seed Indexl for DIS_LINE (3)
001178r 1  7A           					PLY	;Pull High RETURN address from STACK then save it (4)
001179r 1  84 E1        					STY	PCH	;Store program counter High byte (3)
00117Br 1  84 C1        					STY	INDEXH	;Seed Indexh for DIS_LINE (3)
00117Dr 1  4F E2 09     					BBR4	PREG,DO_NULL	;Check for BRK bit set (5)
001180r 1               ;
001180r 1               ; The following three subroutines are contained in the base Monitor code
001180r 1               ; These calls do a register display and disassembles the line of code
001180r 1               ; that caused the BRK to occur. Other code can be added if required
001180r 1               ;	- if replaced with new code, either replace or remove this routine
001180r 1               ;
001180r 1  20 rr rr     					JSR	PRSTAT1	;Display CPU status (6)
001183r 1  20 rr rr     					JSR	DECINDEX	;Decrement Index location (point to BRK ID Byte) (6)
001186r 1  20 rr rr     					JSR	DIS_LINE	;Disassemble current instruction (6)
001189r 1               ;
001189r 1  A9 00        DO_NULL		LDA	#$00	;Clear all PROCESSOR STATUS REGISTER bits (2)
00118Br 1  48           					PHA	; (3)
00118Cr 1  28           					PLP	; (4)
00118Dr 1  64 E9        					STZ	ITAIL	;Zero out input buffer / reset pointers (3)
00118Fr 1  64 E8        					STZ	IHEAD	; (3)
001191r 1  64 E7        					STZ	ICNT	; (3)
001193r 1  6C 08 03     					JMP	(BRKRTVEC0)	;Done BRK service process, re-enter monitor (3)
001196r 1               ;
001196r 1               ;new full duplex IRQ handler (54 clock cycles overhead to this point - includes return)
001196r 1               ;
001196r 1  AD 01 90     INTERUPT0	LDA	SIOSTAT	;Get status register, xfer irq bit to n flag (4)
001199r 1  10 0C        					BPL	REGEXT	;if clear no 6551 irq, exit, else (2/3) (7 clock cycles to exit - take branch)
00119Br 1               ;
00119Br 1  89 08        ASYNC			BIT #%00001000	;check receive bit (2)
00119Dr 1  D0 0F        					BNE RCVCHR	;get received character (2/3) (11 clock cycles to jump to RCV)
00119Fr 1  89 10        					BIT #%00010000	;check xmit bit (2)
0011A1r 1  D0 29        					BNE XMTCHR	;send xmit character (2/3) (15 clock cycles to jump to XMIT)
0011A3r 1               ;no bits on means CTS went high
0011A3r 1  09 10        					ORA #%00010000 ;add CTS high mask to current status (2)
0011A5r 1  85 ED        IRQEXT		STA STTVAL ;update status value (3) (19 clock cycles to here for CTS fallout)
0011A7r 1               ;
0011A7r 1  6C 0A 03     REGEXT		JMP	(IRQRTVEC0) ;handle next irq (5)
0011AAr 1               ;
0011AAr 1  A9 0C        BUFFUL		LDA #%00001100 ;buffer overflow flag (2)
0011ACr 1  80 F7        					BRA IRQEXT ;branch to exit (3)
0011AEr 1               ;
0011AEr 1  AD 00 90     RCVCHR		LDA SIODAT	;get character from 6551 (4)
0011B1r 1  D0 03        					BNE	RCV0	;If not a null character, handle as usual and put into buffer	(2/3)
0011B3r 1  6F FE AD     					BBR6	XMFLAG,BREAKEY	;If Xmodem not active, handle BRK (5)
0011B6r 1               ;
0011B6r 1  A4 E7        RCV0			LDY ICNT	;get buffer counter (3)
0011B8r 1  30 F0        					BMI	BUFFUL	;check against limit, branch if full (2/3)
0011BAr 1               ;
0011BAr 1  A4 E9        					LDY ITAIL ;room in buffer (3)
0011BCr 1  99 00 02     					STA IBUF,Y ;store into buffer (5)
0011BFr 1  E6 E9        					INC	ITAIL	;Increment tail pointer (5)
0011C1r 1  77 E9        					RMB7	ITAIL	;Strip off bit 7, 128 bytes only (5)
0011C3r 1  E6 E7        					INC ICNT ;increment character count (5)
0011C5r 1               ;
0011C5r 1  AD 01 90     					LDA SIOSTAT ;get 6551 status reg (4)
0011C8r 1  29 10        					AND #%00010000 ;check for xmit (2)
0011CAr 1  F0 DB        					BEQ REGEXT	;exit (2/3) (40 if exit, else 39 and drop to XMT)
0011CCr 1               ;
0011CCr 1  A5 EA        XMTCHR		LDA OCNT ;any characters to xmit? (3)
0011CEr 1  F0 10        					BEQ NODATA ;no, turn off xmit (2/3)
0011D0r 1               ;
0011D0r 1  A4 EB        OUTDAT		LDY OHEAD ;get pointer to buffer (3)
0011D2r 1  B9 80 02     					LDA OBUF,Y ;get the next character (4)
0011D5r 1  8D 00 90     					STA SIODAT ;send the data (4)
0011D8r 1               ;
0011D8r 1  E6 EB        					INC	OHEAD	;Increment Head pointer (5)
0011DAr 1  77 EB        					RMB7	OHEAD	;Strip off bit 7, 128 bytes only (5)
0011DCr 1  C6 EA        					DEC OCNT ;decrement counter (5)
0011DEr 1  D0 C7        					BNE	REGEXT	;If not zero, exit and continue normal stuff (2/3) (31 if branch, 30 if continue)
0011E0r 1               ;
0011E0r 1  A0 09        NODATA		LDY	#$09	;get mask for xmit off / rcv on (2)
0011E2r 1  8C 02 90     					STY SIOCOM ;turn off xmit irq bits (5)
0011E5r 1  80 C0        					BRA REGEXT ;exit (3) (13 clock cycles added for turning off xmt)
0011E7r 1               ;
0011E7r 1               ;******************************************************************************
0011E7r 1               ;
0011E7r 1               ;Start of the 6522 BIOS code. Supports basic timer function
0011E7r 1               ; A time of day clock is implemented with a resolution of 4ms
0011E7r 1               ; Timer ticks is set at 250 ticks per second. Page zero holds
0011E7r 1               ; all variables for ticks, seconds, minutes, hours, days
0011E7r 1               ; To keep things simple, days is two bytes so can handle 0-65535 days,
0011E7r 1               ; which is about 179 years. Additional calculations can be made if
0011E7r 1               ; required for a particular application
0011E7r 1               ;
0011E7r 1               ;	Timer Delay Match routine:
0011E7r 1               ;	This provides an accurate and consistent time delay
0011E7r 1               ; using Timer 2 of the 6522. It is configured as a one-shot timer
0011E7r 1               ;	set for 1 millisecond based on clock rate (see config table)
0011E7r 1               ;	It uses an 8-bit value for countdown to reset a MATCH flag on timeout
0011E7r 1               ;	Value can be 1-256 milliseconds ($00 = 256)
0011E7r 1               ;	This routine must also reset the counter if MSDELAY has not decremented
0011E7r 1               ;	to zero, which completes the timer delay
0011E7r 1               ; The delay routine sets the MSDELAY value and MATCH flag to $80,
0011E7r 1               ; then monitors the MATCH flag which is cleared after the delay
0011E7r 1               ;
0011E7r 1               ;	Note that each Timer has it's own exit vector. By default they point to the
0011E7r 1               ;	following IRQ vector (6551 service routine). This allows either timer to be
0011E7r 1               ;	used as a refresh routine by inserting additional code in either loop. The RTC
0011E7r 1               ;	should not be changed, but Timer2 can be provided the user track it's use versus
0011E7r 1               ;	the standard delay routines which also use Timer2
0011E7r 1               ;	NOTE: 24 clock cycles via IRQ vector to get here
0011E7r 1               ;
0011E7r 1               ;Basic use of timer services includes:
0011E7r 1               ;		RTC - time (relative timestamp)
0011E7r 1               ;		Internal delay and timing routines
0011E7r 1               ;		Background refresh tasks
0011E7r 1               ;
0011E7r 1  AD 0D A0     INTERUPT1	LDA	Via1IFR	;Get IRQ flag register, xfer irq bit to n flag (4)
0011EAr 1  10 4F        					BPL	REGEXT1	;if set, 6522 caused irq,(do not branch) (2/3) (7 clock cycles to exit - take branch)
0011ECr 1  89 20        					BIT	#%00100000	;check T2 interrupt bit (2)
0011EEr 1  D0 08        					BNE	DECMSD	;If active, handle T2 timer (MS delay) (2/3)
0011F0r 1  89 40        					BIT #%01000000	;check T1 interrupt bit (2)
0011F2r 1  D0 18        					BNE	INCRTC	;If active, handle T1 timer (RTC) (2/3)
0011F4r 1  85 FA        					STA	STVVAL	;Save in status before exit (3)
0011F6r 1  80 43        					BRA REGEXT1	;branch to next IRQ source, exit (3)
0011F8r 1               ;
0011F8r 1  2C 08 A0     DECMSD		BIT	Via1T2CL	;Clear interrupt for T2 (4)
0011FBr 1  C6 F4        					DEC	MSDELAY	;Decrement 1ms millisecond delay count (5)
0011FDr 1  D0 05        					BNE	RESET_T2	;If not zero, re-enable T2 and exit (2/3)
0011FFr 1  64 F5        					STZ	MATCH	;Else, clear match flag (3) (25 clock cycles to clear MATCH)
001201r 1  6C 12 03     REGEXT2		JMP	(VECINSRT1)	;Done with timer handler, exit (5)
001204r 1               ;
001204r 1  AD 29 03     RESET_T2	LDA	LOAD_6522+$07	;Get T2H value (4)
001207r 1  8D 09 A0     					STA	Via1T2CH	;Reload T2 and re-enable interrupt (4) (31 clock cycles to restart T2)
00120Ar 1  80 F5        					BRA	REGEXT2	;Done with timer handler, exit (3)
00120Cr 1               ;
00120Cr 1  2C 04 A0     INCRTC		BIT	Via1T1CL	;Clear interrupt for T1 (4)
00120Fr 1  C6 EE        					DEC	TICKS	;Decrement RTC tick count (5)
001211r 1  D0 28        					BNE	REGEXT1	;Exit if not zero (2/3)
001213r 1  A9 FA        					LDA	#DF_TICKS ;Get default tick count (2)
001215r 1  85 EE        					STA	TICKS	;Reset Tick count (3)
001217r 1               ;
001217r 1  E6 EF        					INC	SECS	;Increment seconds (5)
001219r 1  A5 EF        					LDA	SECS	;Load it to Areg (3)
00121Br 1  C9 3C        					CMP	#60	;Check for 60 seconds (2)
00121Dr 1  90 1C        					BCC	REGEXT1	;If not, exit (2/3)
00121Fr 1  64 EF        					STZ	SECS	;Else, reset seconds, inc Minutes (3)
001221r 1               ;
001221r 1  E6 F0        					INC	MINS	;Increment Minutes (5)
001223r 1  A5 F0        					LDA	MINS	;Load it to Areg (3)
001225r 1  C9 3C        					CMP	#60	;Check for 60 minutes (2)
001227r 1  90 12        					BCC	REGEXT1	;If not, exit (2/3)
001229r 1  64 F0        					STZ	MINS	;Else, reset Minutes, inc Hours (3)
00122Br 1               ;
00122Br 1  E6 F1        					INC	HOURS	;Increment Hours (5)
00122Dr 1  A5 F1        					LDA	HOURS	;Get it to Areg (3)
00122Fr 1  C9 18        					CMP	#24	;Check for 24 hours (2)
001231r 1  90 08        					BCC	REGEXT1	;If not, exit (2/3)
001233r 1  64 F1        					STZ	HOURS	;Else, reset hours, inc Days (3)
001235r 1               ;
001235r 1  E6 F2        					INC	DAYSL	;Increment low-order Days (5)
001237r 1  D0 02        					BNE	REGEXT1	;If not zero, exit (2/3)
001239r 1  E6 F3        					INC	DAYSH	;Else increment high-order Days (5)
00123Br 1               ;
00123Br 1  6C 10 03     REGEXT1		JMP	(VECINSRT0) ;handle next irq (5)
00123Er 1               ;
00123Er 1  20 rr rr     INIT_PG03	JSR	INIT_VEC	;Init the Vectors first (6)
001241r 1               ;
001241r 1  A0 40        INIT_CFG	LDY	#$40	;Get offset to data (2)
001243r 1  80 02        					BRA	DATA_XFER	;Go move the data to page $03 (3)
001245r 1  A0 20        INIT_VEC	LDY	#$20	;Get offset to data (2)
001247r 1               ;
001247r 1  78           DATA_XFER	SEI	;Disable Interrupts, can be called via JMP table (2)
001248r 1  A2 20        					LDX	#$20	;Set count for 32 bytes (2)
00124Ar 1               DATA_XFLP
00124Ar 1  B9 rr rr     					LDA	VEC_TABLE-1,Y	;Get ROM table data (4)
00124Dr 1  99 FF 02     					STA	SOFTVEC-1,Y	;Store in Soft table location (5)
001250r 1  88           					DEY	;Decrement index (2)
001251r 1  CA           					DEX	;Decrement count (2)
001252r 1  D0 F6        					BNE	DATA_XFLP	;Loop back till done (2/3)
001254r 1  58           					CLI	;re-enable interupts (2)
001255r 1  60           					RTS	;Return to caller (6)
001256r 1               ;
001256r 1               INIT_6551
001256r 1               ;Init the 65C51
001256r 1  78           					SEI	;Disable Interrupts (2)
001257r 1  9C 01 90     					STZ	SIOSTAT	;write to status reg, reset 6551 (3)
00125Ar 1  64 ED        					STZ	STTVAL	;zero status pointer (3)
00125Cr 1  A2 02        					LDX	#$02	;Get count of 2 (2)
00125Er 1               INIT_6551L
00125Er 1  BD 1F 03     					LDA	LOAD_6551-1,X	;Get Current 6551 config parameters (4)
001261r 1  9D 01 90     					STA	SIOBase+1,X	;Write to current 6551 device (5)
001264r 1  CA           					DEX	;Decrement count (2)
001265r 1  D0 F7        					BNE	INIT_6551L	;Loop back until done (2/3)
001267r 1  58           					CLI	;Re-enable Interrupts (2)
001268r 1  60           					RTS	;Return to caller (6)
001269r 1               ;
001269r 1  20 rr rr     INIT_IO		JSR	INIT_6551	;Init the Console first (6)
00126Cr 1               ;
00126Cr 1               INIT_6522
00126Cr 1               ;Init the 65C22
00126Cr 1  78           					SEI	;Disable Interrupts (2)
00126Dr 1  64 FA        					STZ	STVVAL	;zero status pointer (3)
00126Fr 1  A2 0D        					LDX  #$0D	;Get Count of 13 (2)
001271r 1               INIT_6522L
001271r 1  BD 21 03     					LDA	LOAD_6522-1,X	;Get soft parameters (4)
001274r 1  9D 01 A0     					STA	Via1Base+1,X	;Load into 6522 chip (5)
001277r 1  CA           					DEX	;Decrement to next parameter (2)
001278r 1  D0 F7        					BNE	INIT_6522L	;Branch back till all are loaded (2/3)
00127Ar 1  58           					CLI	;Re-enable IRQ (2)
00127Br 1  60           RET				RTS	;Return to caller (6)
00127Cr 1               ;
00127Cr 1               ;END OF BIOS CODE
00127Cr 1               ;
00127Cr 1               ;******************************************************************************
00127Cr 1               ;				.ORG	$FE00	;Reserved for I/O page - do NOT put code here
00127Cr 1               ;******************************************************************************
00127Cr 1               ;
00127Cr 1               ;START OF TOP PAGE - DO NOT MOVE FROM THIS ADDRESS!!
00127Cr 1               ;
00127Cr 1               ;				.ORG	$FF00	;JMP Table, HW Vectors, Cold Init and Vector handlers
00127Cr 1                         .segment "OS"
000000r 1               
000000r 1               ;
000000r 1               ;JUMP Table starts here:
000000r 1               ;	- BIOS calls are from the top down - total of 16
000000r 1               ;	- Monitor calls are from the bottom up
000000r 1               ;	- Reserved calls are in the shrinking middle
000000r 1               ;
000000r 1  4C rr rr     					JMP	RDLINE
000003r 1  4C rr rr     					JMP	RDCHAR
000006r 1  4C rr rr     					JMP	HEXIN2
000009r 1  4C rr rr     					JMP	HEXIN4
00000Cr 1  4C rr rr     					JMP	HEX2ASC
00000Fr 1  4C rr rr     					JMP	BIN2ASC
000012r 1  4C rr rr     					JMP	ASC2BIN
000015r 1  4C rr rr     					JMP	DOLLAR
000018r 1  4C rr rr     					JMP	PRBYTE
00001Br 1  4C rr rr     					JMP	PRWORD
00001Er 1  4C rr rr     					JMP	PRASC
000021r 1  4C rr rr     					JMP	PROMPT
000024r 1  4C rr rr     					JMP	PROMPTR
000027r 1  4C rr rr     					JMP	CONTINUE
00002Ar 1  4C rr rr     					JMP	CROUT
00002Dr 1  4C rr rr     					JMP	SPC
000030r 1  4C rr rr     					JMP	UPTIME
000033r 1  4C rr rr     					JMP	RET
000036r 1  4C rr rr     					JMP	RET
000039r 1  4C rr rr     					JMP	RET
00003Cr 1  4C rr rr     					JMP	RET
00003Fr 1  4C rr rr     					JMP	RET
000042r 1  4C rr rr     					JMP	RET
000045r 1  4C rr rr     					JMP	RET
000048r 1  4C rr rr     					JMP	CHRIN_NW
00004Br 1  4C rr rr     					JMP	CHRIN
00004Er 1  4C rr rr     					JMP	CHROUT
000051r 1  4C rr rr     					JMP	SET_DLY
000054r 1  4C rr rr     					JMP	EXE_MSDLY
000057r 1  4C rr rr     					JMP	EXE_LGDLY
00005Ar 1  4C rr rr     					JMP	EXE_XLDLY
00005Dr 1  4C rr rr     					JMP	SET_PORT
000060r 1  4C rr rr     					JMP	IN_PORT
000063r 1  4C rr rr     					JMP	OUT_PORT
000066r 1  4C rr rr     					JMP	INIT_VEC
000069r 1  4C rr rr     					JMP	INIT_CFG
00006Cr 1  4C rr rr     					JMP	INIT_6551
00006Fr 1  4C rr rr     					JMP	INIT_6522
000072r 1  6C 0E 03     					JMP	(WRMMNVEC0)
000075r 1  6C 0C 03     CMBV			JMP	(CLDMNVEC0)
000078r 1               ;
000078r 1  D8           COLDSTRT	CLD	;Clear decimal mode in case of software call (Zero Ram calls this) (2)
000079r 1  78           					SEI	;Disable Interrupt for same reason as above (2)
00007Ar 1  A2 00        					LDX	#$00	;Index for length of page (2)
00007Cr 1  74 00        PAGE0_LP	STZ	$00,X	;Zero out Page Zero (4)
00007Er 1  CA           					DEX	;Decrement index (2)
00007Fr 1  D0 FB        					BNE	PAGE0_LP	;Loop back till done (2/3)
000081r 1  CA           					DEX	;LDX #$FF ;-) (2)
000082r 1  9A           					TXS	;Set Stack Pointer (2)
000083r 1               ;
000083r 1  20 rr rr     					JSR	INIT_PG03	;Xfer default Vectors/HW Config to $0300 (6)
000086r 1  20 rr rr     					JSR	INIT_IO	;Init I/O - Console, Timers, Ports (6)
000089r 1               ;
000089r 1               ; Send BIOS init msg to console
000089r 1               ;	- note: X reg is zero on return from INIT_IO
000089r 1  BD rr rr     BMSG_LP		LDA	BIOS_MSG,X	;Get BIOS init msg (4)
00008Cr 1  F0 E7        					BEQ	CMBV	;If zero, msg done, goto cold start monitor (2/3)
00008Er 1  20 rr rr     					JSR	CHROUT	;Send to console (6)
000091r 1  E8           					INX	;Increment Index (2)
000092r 1  80 F5        					BRA	BMSG_LP	;Loop back until done (3)
000094r 1               ;
000094r 1               IRQ_VECTOR	;This is the ROM start for the BRK/IRQ handler
000094r 1  48           					PHA	;Save A Reg (3)
000095r 1  DA           					PHX	;Save X Reg (3)
000096r 1  5A           					PHY	;Save Y Reg (3)
000097r 1  BA           					TSX	;Get Stack pointer (2)
000098r 1  BD 04 01     					LDA	$0100+4,X	;Get Status Register (4)
00009Br 1  29 10        					AND	#$10	;Mask for BRK bit set (2)
00009Dr 1  D0 03        					BNE	DO_BRK	;If set, handle BRK (2/3)
00009Fr 1  6C 04 03     					JMP	(IRQVEC0)	;Jump to Soft vectored IRQ Handler (5) (24 clock cycles to vector routine)
0000A2r 1  6C 02 03     DO_BRK		JMP	(BRKVEC0)	;Jump to Soft vectored BRK Handler (5) (25 clock cycles to vector routine)
0000A5r 1               ;
0000A5r 1               IRQ_EXIT0	;This is the standard return for the IRQ/BRK handler routines
0000A5r 1  7A           					PLY	;Restore Y Reg (4)
0000A6r 1  FA           					PLX	;Restore X Reg (4)
0000A7r 1  68           					PLA	;Restore A Reg (4)
0000A8r 1  40           					RTI	;Return from IRQ/BRK routine (6) (18 clock cycles from vector jump to IRQ end)
0000A9r 1               ;
0000A9r 1               ;******************************************************************************
0000A9r 1               ;
0000A9r 1               ;START OF BIOS DEFAULT VECTOR DATA AND HARDWARE CONFIGURATION DATA
0000A9r 1               ;
0000A9r 1               ;The default location for the NMI/BRK/IRQ Vector data is at location $0300
0000A9r 1               ; details of the layout are listed at the top of the source file
0000A9r 1               ;	there are 8 main vectors and 8 vector inserts, one is used for the 6522
0000A9r 1               ;
0000A9r 1               ;The default location for the hardware configuration data is at location $0320
0000A9r 1               ; it is mostly a freeform table which gets copied from ROM to page $03
0000A9r 1               ; the default size for the config table is 32 bytes, 17 bytes are free
0000A9r 1               ;
0000A9r 1               VEC_TABLE	;Vector table data for default ROM handlers
0000A9r 1               ;Vector set 0
0000A9r 1  rr rr        					.addr	NMI_VECTOR	;NMI Location in ROM
0000ABr 1  rr rr        					.addr	BRKINSTR0	;BRK Location in ROM
0000ADr 1  rr rr        					.addr	INTERUPT1	;IRQ Location in ROM
0000AFr 1               ;
0000AFr 1  rr rr        					.addr	WRM_MON	;NMI return handler in ROM
0000B1r 1  rr rr        					.addr	WRM_MON	;BRK return handler in ROM
0000B3r 1  rr rr        					.addr	IRQ_EXIT0	;IRQ return handler in ROM
0000B5r 1               ;
0000B5r 1  rr rr        					.addr	MONITOR	;Monitor Cold start
0000B7r 1  rr rr        					.addr	WRM_MON	;Monitor Warm start
0000B9r 1               ;
0000B9r 1               ;Vector Inserts (total of 8)
0000B9r 1               ; these can be used as required, one is used by default for the 6522
0000B9r 1               ; as NMI/BRK/IRQ and the Monitor are vectored, all can be extended
0000B9r 1               ; by using these reserved vectors.
0000B9r 1  rr rr        					.addr	INTERUPT0	;Insert 0 Location - for 6522 timer1
0000BBr 1  rr rr        					.addr	INTERUPT0	;Insert 1 Location - for 6522 timer2
0000BDr 1  FF FF        					.addr	$FFFF	;Insert 2 Location
0000BFr 1  FF FF        					.addr	$FFFF	;Insert 3 Location
0000C1r 1  FF FF        					.addr	$FFFF	;Insert 4 Location
0000C3r 1  FF FF        					.addr	$FFFF	;Insert 5 Location
0000C5r 1  FF FF        					.addr	$FFFF	;Insert 6 Location
0000C7r 1  FF FF        					.addr	$FFFF	;Insert 7 Location
0000C9r 1               ;
0000C9r 1               CFG_TABLE	;Configuration table for hardware devices
0000C9r 1               ;
0000C9r 1               CFG_6551	;2 bytes required for 6551
0000C9r 1               ; Command Register bit definitions:
0000C9r 1               ; Bit 7/6	= Parity Control: 0,0 = Odd Parity
0000C9r 1               ; Bit 5		= Parity enable: 0 = No Parity
0000C9r 1               ; Bit 4		= Receiver Echo mode: 0 = Normal
0000C9r 1               ; Bit 3/2	= Transmitter Interrupt Control:
0000C9r 1               ; Bit 1		= Receiver Interrupt Control: 0 = Enabled / 1 = Disabled
0000C9r 1               ; Bit 0		= DTR Control: 1 = DTR Ready
0000C9r 1               ;
0000C9r 1               ; Default for setup:		%00001001 ($09)
0000C9r 1               ; Default for transmit:	%00000101 ($05)
0000C9r 1  09           					.byte	$09	;Default 65C51 Command register, transmit/receiver IRQ output enabled)
0000CAr 1               ;
0000CAr 1               ; Baud Select Register:
0000CAr 1               ; Bit 7		= Stop Bit: 0 = 1 Stop Bit
0000CAr 1               ; Bit 6/5	= Word Length: 00 = 8 bits
0000CAr 1               ; Bit 4		= Receiver Clock Source: 0 = External Clk 1 = Baud Rate Gen
0000CAr 1               ; Bit 3-0	= Baud Rate Table: 1111 = 19.2K Baud (default)
0000CAr 1               ;
0000CAr 1               ; Default for setup:		%00011111 ($1F) - 19.2K, 8 data, 1 stop)
0000CAr 1  1F           					.byte	$1F	;Default 65C51 Control register, (115.2K,no parity,8 data bits,1 stop bit)
0000CBr 1               ;
0000CBr 1               CFG_6522	;13 bytes required for 6522
0000CBr 1               ;Timer 1 load value is based on CPU clock frequency for 4 milliseconds - RTC use
0000CBr 1               ; Note that 2 needs to be subtracted from the count value, i.e., 16000 needs to be 15998, etc.
0000CBr 1               ; This corresponds to the W65C22 datasheet showing N+2 between interrupts in continuous mode
0000CBr 1               ; 16MHz = 63998, 10MHz = 39998, 8MHz = 31998, 6MHz = 23998, 5MHz = 19998, 4MHz = 15998, 2MHz = 7998
0000CBr 1               ; 16MHz = $F9FE, 10MHz = $9C3E, 8MHz = $7CFE, 6MHz = $5DBE, 5MHz = $4E1E, 4MHz = $3E7E, 2MHz = $1F3E
0000CBr 1               ;
0000CBr 1               ;Timer 2 load value is based on CPU clock frequency for 1 millisecond - delay use
0000CBr 1               ;	- Timer 2 value needs to be adjusted to compensate for the time to respond to the interrupt
0000CBr 1               ;	- and reset the timer for another 1ms countdown, which is 55 clock cycles
0000CBr 1               ;	- As Timer 2 counts clock cycles, each of the values should be adjusted by subtracting 55+2
0000CBr 1               ;	16MHz = 15943,	10MHz = 9943,		8MHz = 7943,	6MHz = 5943,	5MHz = 4943,	4MHz = 3943,	2MHz = 1943
0000CBr 1               ; 16MHz = $3E47,	10MHz = $26D7,	8MHz = $1F07,	6MHz = $1737,	5MHz = $134F,	4MHz = $0F67,	2MHz = $0797
0000CBr 1               ;
0000CBr 1               ; only the ports that are needed for config are shown below:
0000CBr 1               ;
0000CBr 1  00           					.byte	$00	;Data Direction register Port B
0000CCr 1  00           					.byte	$00	;Data Direction register Port A
0000CDr 1  7E           					.byte	$7E	;T1CL - set for CPU clock as above - $04
0000CEr 1  3E           					.byte	$3E	;T1CH - to 4ms (250 interupts per second) - $05
0000CFr 1  00           					.byte	$00	;T1LL - T1 counter latch low
0000D0r 1  00           					.byte	$00	;T1LH - T1 counter latch high
0000D1r 1  67           					.byte	$67	;T2CL - T2 counter low count - set for 1ms (adjusted)
0000D2r 1  0F           					.byte	$0F	;T2CH - T2 counter high count - used for delay timer
0000D3r 1  00           					.byte	$00	;SR - Shift register
0000D4r 1  40           					.byte	$40	;ACR - Aux control register
0000D5r 1  00           					.byte	$00	;PCR - Peripheral control register
0000D6r 1  7F           					.byte	$7F	;IFR - Interrupt flag register (clear all)
0000D7r 1  E0           					.byte	$E0	;IER - Interrupt enable register (enable T1/T2)
0000D8r 1  FF           					.byte	$FF	;Free config byte
0000D9r 1               ;
0000D9r 1               ;Reserved for additional I/O devices (16 bytes total)
0000D9r 1  FF FF FF FF  					.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
0000DDr 1  FF FF FF FF  
0000E1r 1  FF FF FF FF  					.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
0000E5r 1  FF FF FF FF  
0000E9r 1               ;
0000E9r 1               ;END OF BIOS VECTOR DATA AND HARDWARE DEFAULT CONFIGURATION DATA
0000E9r 1               ;******************************************************************************
0000E9r 1               ;
0000E9r 1               ;BIOS init message - sent before jumping to the monitor coldstart vector
0000E9r 1  0D 0A        BIOS_MSG	.byte	$0D,$0A
0000EBr 1  42 49 4F 53  					.byte	"BIOS 1.4 "
0000EFr 1  20 31 2E 34  
0000F3r 1  20           
0000F4r 1  34 4D 48 7A  					.byte	"4MHz"
0000F8r 1  00           					.byte	$00	;Terminate string
0000F9r 1               ;
0000F9r 1               ;65C02 Vectors:
0000F9r 1               ;					.ORG	$FFFA
0000F9r 1                                   .segment "VECTORS"
000000r 1               
000000r 1  00 03        					.addr	NMIVEC0	;NMI
000002r 1  rr rr        					.addr	COLDSTRT	;RESET
000004r 1  rr rr        					.addr	IRQ_VECTOR	;IRQ
000006r 1               ;					.END
000006r 1               
